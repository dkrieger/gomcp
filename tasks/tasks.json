{
  "tasks": [
    {
      "id": 1,
      "title": "Define Package Structure",
      "description": "Create the initial project structure with all required packages and directories as specified in the PRD.",
      "details": "Create the following directory structure:\n- github.com/localrivet/gomcp/\n  - gomcp.go (main entry point)\n  - mcp/ (core types and specification implementation)\n    - v20241105/ (2024-11-05 specification implementation)\n    - v20250326/ (2025-03-26 specification implementation)\n    - draft/ (latest draft specification implementation)\n  - server/ (server implementation)\n  - client/ (client implementation)\n  - transport/ (transport layer implementations)\n    - stdio/ (Standard I/O transport)\n    - ws/ (WebSocket transport)\n    - sse/ (Server-Sent Events transport)\n    - http/ (HTTP transport)\n  - util/ (utility packages)\n    - slog/ (structured logging utilities)\n    - schema/ (schema generation and validation)\n    - validator/ (argument validation utilities)\n    - conversion/ (type conversion utilities)\n\nEnsure all directories have appropriate README.md files explaining their purpose.",
      "testStrategy": "Verify that all directories and files are created with the correct structure. Create a simple test that imports the main package to ensure it compiles correctly.",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Initialize Git Repository with go.mod",
          "description": "Create a new Git repository and initialize the Go module with go.mod file and a basic README.md",
          "dependencies": [],
          "details": "Create a new repository, run 'go mod init github.com/username/project-name', create a README.md with project overview, goals, and basic usage instructions. Include license information and contribution guidelines.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Create Directory Structure",
          "description": "Set up the directory structure according to the PRD specifications",
          "dependencies": [
            1
          ],
          "details": "Create directories for cmd/, pkg/, internal/, docs/, examples/, and tests/ following Go project best practices. Ensure the structure aligns with the PRD requirements and facilitates clean separation of concerns.\n<info added on 2025-05-15T19:59:29.653Z>\nCreate directories for cmd/, pkg/, internal/, docs/, examples/, and tests/ following Go project best practices. Ensure the structure aligns with the PRD requirements and facilitates clean separation of concerns.\n\nVerify that the existing directory structure includes the main directories specified in the PRD: mcp/, server/, client/, transport/, and util/ with their appropriate subdirectories. Check for any missing components and ensure all required directories are properly organized. The structure should support the clean separation of concerns between the MCP server, client implementations, and transport mechanisms. Confirm that each directory has the appropriate placeholder files or initial code structures to maintain Git tracking.\n</info added on 2025-05-15T19:59:29.653Z>",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Setup Package Documentation",
          "description": "Create initial documentation files for each package",
          "dependencies": [
            2
          ],
          "details": "Add package-level documentation with doc.go files in each directory. Include purpose, usage examples, and API descriptions. Follow godoc conventions to ensure documentation is accessible through standard Go tools.",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Create CI Configuration Files",
          "description": "Set up continuous integration configuration files",
          "dependencies": [
            1
          ],
          "details": "Create GitHub Actions or similar CI workflow files. Include configurations for running tests, linting, and building the project. Set up automated testing for multiple Go versions and operating systems.",
          "status": "done"
        },
        {
          "id": 5,
          "title": "Add Development Tools Configuration",
          "description": "Configure development tools like linters, formatters, and editor settings",
          "dependencies": [
            1,
            2
          ],
          "details": "Add .gitignore file with appropriate entries for Go projects. Configure golangci-lint with .golangci.yml. Add .editorconfig for consistent formatting. Include Makefile or similar build scripts for common development tasks.",
          "status": "done"
        }
      ]
    },
    {
      "id": 2,
      "title": "Implement Core MCP Types for v20241105",
      "description": "Define all core protocol types for the 2024-11-05 specification version in the mcp/v20241105 package.",
      "details": "Create type definitions for all MCP message types according to the 2024-11-05 specification:\n\n```go\n// mcp/v20241105/types.go\npackage v20241105\n\n// Message represents the base MCP message structure\ntype Message struct {\n\tType    string          `json:\"type\"`\n\tVersion string          `json:\"version\"`\n\tID      string          `json:\"id,omitempty\"`\n\tData    json.RawMessage `json:\"data,omitempty\"`\n}\n\n// Define all message types (Tool, Resource, Prompt, etc.)\ntype ToolMessage struct {\n\t// Tool message fields\n}\n\n// Additional message types...\n```\n\nImplement marshaling/unmarshaling functions for all types. Ensure all types are properly documented with comments that will appear in godoc.",
      "testStrategy": "Create comprehensive unit tests for each type, including marshaling and unmarshaling tests with sample JSON data. Test edge cases like empty fields, maximum field sizes, and invalid data.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Implement Core MCP Types for v20250326",
      "description": "Define all core protocol types for the 2025-03-26 specification version in the mcp/v20250326 package.",
      "details": "Create type definitions for all MCP message types according to the 2025-03-26 specification, following the same pattern as the v20241105 implementation but with any specification differences incorporated:\n\n```go\n// mcp/v20250326/types.go\npackage v20250326\n\n// Message represents the base MCP message structure\ntype Message struct {\n\tType    string          `json:\"type\"`\n\tVersion string          `json:\"version\"`\n\tID      string          `json:\"id,omitempty\"`\n\tData    json.RawMessage `json:\"data,omitempty\"`\n}\n\n// Define all message types with any v20250326-specific changes\n```\n\nImplement marshaling/unmarshaling functions for all types. Ensure all types are properly documented with comments that will appear in godoc.",
      "testStrategy": "Create comprehensive unit tests for each type, including marshaling and unmarshaling tests with sample JSON data. Test edge cases and ensure compatibility with the previous version where appropriate.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Implement Core MCP Types for Draft Version",
      "description": "Define all core protocol types for the latest draft specification version in the mcp/draft package.",
      "details": "Create type definitions for all MCP message types according to the latest draft specification, following the same pattern as the previous implementations but with any draft specification differences incorporated:\n\n```go\n// mcp/draft/types.go\npackage draft\n\n// Message represents the base MCP message structure\ntype Message struct {\n\tType    string          `json:\"type\"`\n\tVersion string          `json:\"version\"`\n\tID      string          `json:\"id,omitempty\"`\n\tData    json.RawMessage `json:\"data,omitempty\"`\n}\n\n// Define all message types with any draft-specific changes\n```\n\nImplement marshaling/unmarshaling functions for all types. Ensure all types are properly documented with comments that will appear in godoc.",
      "testStrategy": "Create comprehensive unit tests for each type, including marshaling and unmarshaling tests with sample JSON data. Test edge cases and ensure compatibility with previous versions where appropriate.",
      "priority": "medium",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Implement Version Detection and Negotiation",
      "description": "Create a version detection and negotiation system that automatically handles different MCP specification versions.",
      "details": "Implement a version detection and negotiation system in the mcp package:\n\n```go\n// mcp/version.go\npackage mcp\n\n// VersionDetector detects and negotiates MCP versions\ntype VersionDetector struct {\n\t// Implementation details\n}\n\n// DetectVersion determines the appropriate MCP version based on a message\nfunc (d *VersionDetector) DetectVersion(message []byte) (string, error) {\n\t// Parse message and extract version\n\t// Return appropriate version string\n}\n\n// NegotiateVersion handles version negotiation between client and server\nfunc (d *VersionDetector) NegotiateVersion(clientVersions []string, serverVersions []string) (string, error) {\n\t// Implement version negotiation logic\n\t// Return the highest mutually supported version\n}\n```\n\nEnsure the system can:\n1. Automatically detect the version from incoming messages\n2. Negotiate the highest mutually supported version\n3. Provide appropriate type adapters for converting between versions\n4. Handle unknown or unsupported versions gracefully",
      "testStrategy": "Create unit tests for version detection with messages from all supported versions. Test negotiation with various version combinations. Test edge cases like unknown versions, malformed version strings, and empty version lists.",
      "priority": "high",
      "dependencies": [
        2,
        3,
        4
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Implement Structured Logging (slog) Package",
      "description": "Implement or refine the structured logging package (util/slog) to provide flexible, configurable logging for the library.",
      "details": "Implement a structured logging package that supports:\n\n```go\n// util/slog/logger.go\npackage slog\n\n// LogLevel represents logging severity levels\ntype LogLevel int\n\nconst (\n\tLevelDebug LogLevel = iota\n\tLevelInfo\n\tLevelWarn\n\tLevelError\n)\n\n// Logger provides structured logging capabilities\ntype Logger struct {\n\t// Implementation details\n}\n\n// NewLogger creates a new logger with the given options\nfunc NewLogger(options ...Option) *Logger {\n\t// Implementation\n}\n\n// Option represents a logger configuration option\ntype Option func(*Logger)\n\n// WithLevel sets the logger's level\nfunc WithLevel(level LogLevel) Option {\n\t// Implementation\n}\n\n// WithOutput sets the logger's output destination\nfunc WithOutput(output io.Writer) Option {\n\t// Implementation\n}\n\n// WithFormat sets the logger's output format\nfunc WithFormat(format string) Option {\n\t// Implementation\n}\n\n// Log methods\nfunc (l *Logger) Debug(msg string, fields ...Field) {}\nfunc (l *Logger) Info(msg string, fields ...Field) {}\nfunc (l *Logger) Warn(msg string, fields ...Field) {}\nfunc (l *Logger) Error(msg string, fields ...Field) {}\n```\n\nImplement support for:\n- Multiple output formats (JSON, text)\n- File, stdout, stderr output options\n- Log file rotation with timestamps\n- Runtime log level adjustment\n- Structured fields for context",
      "testStrategy": "Create unit tests for all logger functionality. Test different output formats, log levels, and output destinations. Test log rotation functionality. Test concurrent logging from multiple goroutines.",
      "priority": "medium",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Implement Schema Generation and Validation",
      "description": "Implement or refine the schema generation and validation package (util/schema) to support automatic JSON Schema generation from Go structs.",
      "details": "Implement a schema generation and validation package that supports:\n\n```go\n// util/schema/schema.go\npackage schema\n\n// Generator creates JSON Schema from Go structs\ntype Generator struct {\n\t// Implementation details\n}\n\n// NewGenerator creates a new schema generator\nfunc NewGenerator() *Generator {\n\t// Implementation\n}\n\n// GenerateSchema generates a JSON Schema from a Go struct type\nfunc (g *Generator) GenerateSchema(v interface{}) (map[string]interface{}, error) {\n\t// Use reflection to analyze struct fields and tags\n\t// Generate appropriate JSON Schema\n}\n\n// Validator validates data against a schema\ntype Validator struct {\n\t// Implementation details\n}\n\n// NewValidator creates a new schema validator\nfunc NewValidator(schema map[string]interface{}) *Validator {\n\t// Implementation\n}\n\n// Validate validates data against the schema\nfunc (v *Validator) Validate(data interface{}) error {\n\t// Validate data against schema\n}\n```\n\nImplement support for struct tags:\n- `required:\"true\"` - Mark fields as required\n- `enum:\"value1,value2\"` - Restrict string values\n- `min:\"0\" max:\"100\"` - Set numeric boundaries\n- `format:\"email\"` - Validate string formats\n- `default:\"value\"` - Set default values\n- `description:\"text\"` - Add field descriptions",
      "testStrategy": "Create unit tests for schema generation with various struct types and tags. Test validation against generated schemas with valid and invalid data. Test edge cases like nested structs, arrays, and maps.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement Argument Validation Package",
      "description": "Implement or refine the argument validation package (util/validator) to provide flexible validation for function arguments.",
      "details": "Implement an argument validation package that supports:\n\n```go\n// util/validator/validator.go\npackage validator\n\n// Validator provides validation functionality\ntype Validator struct {\n\terrors []error\n}\n\n// NewValidator creates a new validator\nfunc NewValidator() *Validator {\n\treturn &Validator{}\n}\n\n// Required validates that a value is not nil or empty\nfunc (v *Validator) Required(name string, value interface{}) *Validator {\n\t// Implementation\n\treturn v\n}\n\n// Min validates that a numeric value is at least min\nfunc (v *Validator) Min(name string, value, min float64) *Validator {\n\t// Implementation\n\treturn v\n}\n\n// Max validates that a numeric value is at most max\nfunc (v *Validator) Max(name string, value, max float64) *Validator {\n\t// Implementation\n\treturn v\n}\n\n// Enum validates that a string value is one of the allowed values\nfunc (v *Validator) Enum(name string, value string, allowed ...string) *Validator {\n\t// Implementation\n\treturn v\n}\n\n// Format validates that a string matches a format pattern\nfunc (v *Validator) Format(name string, value string, format string) *Validator {\n\t// Implementation\n\treturn v\n}\n\n// Error returns the first validation error or nil if there are none\nfunc (v *Validator) Error() error {\n\tif len(v.errors) == 0 {\n\t\treturn nil\n\t}\n\treturn v.errors[0]\n}\n\n// Errors returns all validation errors\nfunc (v *Validator) Errors() []error {\n\treturn v.errors\n}\n```\n\nImplement support for common validations:\n- Required values\n- Numeric ranges\n- String formats\n- Enum values\n- Custom validation functions",
      "testStrategy": "Create unit tests for all validation functions with valid and invalid inputs. Test chaining multiple validations. Test error messages for clarity and correctness.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement Type Conversion Package",
      "description": "Implement or refine the type conversion package (util/conversion) to simplify working with dynamic data types.",
      "details": "Implement a type conversion package that supports:\n\n```go\n// util/conversion/conversion.go\npackage conversion\n\n// ToString converts a value to a string\nfunc ToString(v interface{}) (string, error) {\n\t// Implementation\n}\n\n// ToInt converts a value to an int\nfunc ToInt(v interface{}) (int, error) {\n\t// Implementation\n}\n\n// ToFloat64 converts a value to a float64\nfunc ToFloat64(v interface{}) (float64, error) {\n\t// Implementation\n}\n\n// ToBool converts a value to a bool\nfunc ToBool(v interface{}) (bool, error) {\n\t// Implementation\n}\n\n// ToMap converts a value to a map[string]interface{}\nfunc ToMap(v interface{}) (map[string]interface{}, error) {\n\t// Implementation\n}\n\n// ToSlice converts a value to a []interface{}\nfunc ToSlice(v interface{}) ([]interface{}, error) {\n\t// Implementation\n}\n```\n\nImplement support for common conversions:\n- String to/from numeric types\n- String to/from boolean\n- JSON to/from Go types\n- Map and slice conversions\n- Time and date conversions",
      "testStrategy": "Create unit tests for all conversion functions with various input types. Test edge cases like empty values, zero values, and invalid conversions. Test error messages for clarity and correctness.",
      "priority": "medium",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Implement Server Core",
      "description": "Implement the core server functionality in the server package, including the server struct and basic methods.",
      "details": "Implement the core server functionality:\n\n```go\n// server/server.go\npackage server\n\n// Server represents an MCP server\ntype Server struct {\n\tname        string\n\ttools       map[string]*Tool\n\tresources   map[string]*Resource\n\tprompts     map[string]*Prompt\n\troot        RootHandler\n\ttransport   Transport\n\tlogger      *slog.Logger\n\tversionDetector *mcp.VersionDetector\n\t// Additional fields\n}\n\n// NewServer creates a new MCP server\nfunc NewServer(name string, options ...Option) *Server {\n\t// Implementation\n}\n\n// Option represents a server configuration option\ntype Option func(*Server)\n\n// WithLogger sets the server's logger\nfunc WithLogger(logger *slog.Logger) Option {\n\t// Implementation\n}\n\n// Tool registers a tool with the server\nfunc (s *Server) Tool(name, description string, handler ToolHandler) *Server {\n\t// Implementation\n\treturn s\n}\n\n// Resource registers a resource with the server\nfunc (s *Server) Resource(path, description string, handler ResourceHandler) *Server {\n\t// Implementation\n\treturn s\n}\n\n// Prompt registers a prompt with the server\nfunc (s *Server) Prompt(name, description string, templates ...PromptTemplate) *Server {\n\t// Implementation\n\treturn s\n}\n\n// Root sets the root resource handler\nfunc (s *Server) Root(handler RootHandler) *Server {\n\t// Implementation\n\treturn s\n}\n\n// Run starts the server\nfunc (s *Server) Run() error {\n\t// Implementation\n}\n```\n\nImplement the server context:\n\n```go\n// server/context.go\npackage server\n\n// Context represents the context for a server request\ntype Context struct {\n\tRequest  *Request\n\tResponse *Response\n\tLogger   *slog.Logger\n\t// Additional fields\n}\n\n// Request represents an incoming request\ntype Request struct {\n\t// Implementation\n}\n\n// Response represents an outgoing response\ntype Response struct {\n\t// Implementation\n}\n```",
      "testStrategy": "Create unit tests for server creation and configuration. Test registering tools, resources, and prompts. Test the server context. Mock the transport layer for testing.",
      "priority": "high",
      "dependencies": [
        5,
        6,
        7,
        8,
        9
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Implement Tool Registration and Execution",
      "description": "Implement tool registration and execution functionality in the server package.",
      "details": "Implement tool registration and execution:\n\n```go\n// server/tool.go\npackage server\n\n// ToolHandler represents a tool handler function\ntype ToolHandler func(ctx *Context, args interface{}) (interface{}, error)\n\n// Tool represents a registered tool\ntype Tool struct {\n\tName        string\n\tDescription string\n\tHandler     ToolHandler\n\tSchema      map[string]interface{}\n\t// Additional fields\n}\n\n// registerTool registers a tool with the server\nfunc (s *Server) registerTool(name, description string, handler ToolHandler, schema map[string]interface{}) *Server {\n\t// Implementation\n\treturn s\n}\n\n// executeTool executes a tool\nfunc (s *Server) executeTool(ctx *Context, name string, args map[string]interface{}) (interface{}, error) {\n\t// Implementation\n}\n```\n\nImplement struct tag-based parameter validation:\n\n```go\n// Extract schema from handler function parameter type\nfunc extractSchema(handler interface{}) (map[string]interface{}, error) {\n\t// Use reflection to analyze the handler's parameter type\n\t// Extract struct tags and generate schema\n}\n\n// Validate and convert arguments to the appropriate type\nfunc validateAndConvertArgs(schema map[string]interface{}, args map[string]interface{}, paramType reflect.Type) (interface{}, error) {\n\t// Validate args against schema\n\t// Convert args to the appropriate struct type\n}\n```",
      "testStrategy": "Create unit tests for tool registration with various handler signatures. Test tool execution with valid and invalid arguments. Test struct tag-based validation. Test error handling for missing or invalid tools.",
      "priority": "high",
      "dependencies": [
        10
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Tool struct and registration method",
          "description": "Complete the implementation of the Tool struct and the registerTool method to allow tools to be registered with the server.",
          "dependencies": [],
          "details": "Implement the Tool struct with all required fields. Complete the registerTool method to store registered tools in a map within the Server struct. Add a tools map field to the Server struct if it doesn't exist. The method should validate that the tool name is unique and return the server instance for method chaining.\n<info added on 2025-05-15T18:20:59.878Z>\nImplement the Tool struct with all required fields. Complete the registerTool method to store registered tools in a map within the Server struct. Add a tools map field to the Server struct if it doesn't exist. The method should validate that the tool name is unique and return the server instance for method chaining.\n\nThe implementation has been completed with the following components:\n1. The Tool struct has been implemented with all necessary fields to represent a tool in the system.\n2. A registerTool method has been added to the serverImpl struct that properly stores tools in a tools map.\n3. The existing Tool method in server.go has been updated to utilize the new registerTool method.\n4. Validation logic has been implemented to check for:\n   - Empty tool names (with appropriate warnings)\n   - Duplicate tool names (with appropriate warnings)\n5. The implementation maintains the server's fluent API design by returning the server instance for method chaining.\n6. Comprehensive tests have been written to verify:\n   - Successful tool registration\n   - Proper handling of duplicate tools\n   - Validation of tool names\n   - Type conversion correctness\n7. All tests are now passing, confirming the implementation works as expected.\n</info added on 2025-05-15T18:20:59.878Z>",
          "status": "done",
          "testStrategy": "Write unit tests that register multiple tools and verify they are correctly stored in the server's tools map. Include tests for duplicate tool names."
        },
        {
          "id": 2,
          "title": "Implement schema extraction using reflection",
          "description": "Implement the extractSchema function that uses reflection to analyze a handler's parameter type and generate a schema based on struct tags.",
          "dependencies": [
            1
          ],
          "details": "Use the reflect package to examine the handler function's parameter type. For struct types, iterate through fields and extract tags like `json:\"field_name\"` and `description:\"field description\"`. Generate a JSON Schema compatible map that describes the expected input parameters. Handle nested structs, basic types (string, int, bool, etc.), and slices/arrays.\n<info added on 2025-05-15T18:25:03.195Z>\nUse the reflect package to examine the handler function's parameter type. For struct types, iterate through fields and extract tags like `json:\\\"field_name\\\"` and `description:\\\"field description\\\"`. Generate a JSON Schema compatible map that describes the expected input parameters. Handle nested structs, basic types (string, int, bool, etc.), and slices/arrays.\n\nThe implementation has been completed with a comprehensive approach to schema extraction:\n\n1. Created a robust schema generation system using Go's reflection capabilities\n2. Implemented `generateSchemaFromStruct` function that analyzes struct types and produces corresponding JSON Schema\n3. Developed `generatePropertySchema` function to handle individual field schema generation with proper type mapping\n4. Added support for complex types including:\n   - Nested structs with proper property nesting\n   - Arrays/slices with appropriate item type definitions\n   - Maps with key/value type information\n5. Enhanced schema metadata using struct tags for:\n   - Field descriptions via `description` tags\n   - Enumeration values via `enum` tags\n   - Validation constraints (min/max values, patterns, formats)\n6. Created `getJSONType` utility to accurately map Go types to JSON Schema types\n7. Ensured proper handling of all struct tags including special cases\n8. Maintained backward compatibility with existing code\n9. Fixed type conversion issues in nested schema generation\n\nThe implementation now provides comprehensive schema extraction for all supported Go types while preserving compatibility with the existing codebase.\n</info added on 2025-05-15T18:25:03.195Z>",
          "status": "done",
          "testStrategy": "Create test cases with various struct types containing different field types and tags. Verify the generated schema correctly represents the structure and constraints defined in the struct."
        },
        {
          "id": 3,
          "title": "Implement argument validation and conversion",
          "description": "Implement the validateAndConvertArgs function to validate incoming arguments against the schema and convert them to the appropriate type.",
          "dependencies": [
            2
          ],
          "details": "Compare incoming arguments against the schema to ensure all required fields are present and of the correct type. Convert the validated map of arguments into an instance of the parameter type expected by the handler function. Use reflection to set field values. Handle type conversions (e.g., string to int) and return appropriate errors for validation failures.\n<info added on 2025-05-15T19:06:21.336Z>\nCompare incoming arguments against the schema to ensure all required fields are present and of the correct type. Convert the validated map of arguments into an instance of the parameter type expected by the handler function. Use reflection to set field values. Handle type conversions (e.g., string to int) and return appropriate errors for validation failures.\n\nAfter analysis, we identified significant code duplication between server/tool.go and the util/schema package. Instead of implementing a custom validateAndConvertArgs function within the server package, we refactored to use the schema.ValidateAndConvertArgs function directly from the utils/schema package.\n\nThe refactoring included:\n1. Removing the redundant validateAndConvertArgs function from server/tool.go\n2. Updating executeTool to use schema.ValidateAndConvertArgs for validation and conversion\n3. Removing other helper functions like isPrimitiveType and convertValue\n4. Updating setFieldValue to use schema.NewConverter().Convert\n5. Fixing tests to use the util/schema package functionality with proper imports\n\nThis refactoring eliminates code duplication and adheres to the DRY principle, making the codebase more maintainable and consistent. All tests are now passing with the new implementation.\n</info added on 2025-05-15T19:06:21.336Z>",
          "status": "done",
          "testStrategy": "Test with valid and invalid argument sets. Verify that validation errors are returned for missing required fields, incorrect types, and values outside constraints. Test that valid arguments are correctly converted to the expected struct type."
        },
        {
          "id": 4,
          "title": "Implement tool execution functionality",
          "description": "Complete the executeTool method to find a registered tool by name and execute its handler with the provided arguments.",
          "dependencies": [
            1,
            3
          ],
          "details": "Look up the requested tool by name in the server's tools map. If found, validate and convert the provided arguments using validateAndConvertArgs. Call the tool's handler function with the context and converted arguments. Return the result or error from the handler. If the tool is not found, return an appropriate error.\n<info added on 2025-05-15T19:07:44.698Z>\nLook up the requested tool by name in the server's tools map. If found, validate and convert the provided arguments using validateAndConvertArgs. Call the tool's handler function with the context and converted arguments. Return the result or error from the handler. If the tool is not found, return an appropriate error.\n\nThe implementation has been completed in server/tool.go with the following components:\n\n1. The `executeTool` method:\n   - Uses read locks for thread-safe access to the tools map\n   - Performs tool lookup by name\n   - Returns appropriate error if tool not found\n   - Uses reflection to get handler's parameter type\n   - Leverages schema.ValidateAndConvertArgs for argument validation\n   - Executes the tool handler with context and converted arguments\n   - Returns results or properly wrapped errors\n\n2. The `ProcessToolCall` method:\n   - Validates request format\n   - Calls executeTool with tool name and arguments\n   - Sets response type and data\n   - Handles error conditions\n\nThe implementation follows best practices with thread-safe access, proper error handling, separation of concerns, and appropriate use of the schema package. All tests are passing, confirming the functionality works correctly.\n</info added on 2025-05-15T19:07:44.698Z>",
          "status": "done",
          "testStrategy": "Test execution of registered tools with valid and invalid arguments. Verify correct results are returned for valid calls and appropriate errors for invalid calls or non-existent tools."
        },
        {
          "id": 5,
          "title": "Integrate tool registration with server initialization",
          "description": "Update the server initialization code to support registering tools during setup and expose a public API for tool registration.",
          "dependencies": [
            4
          ],
          "details": "Add a public RegisterTool method to the Server that wraps the internal registerTool method. Update the server's New or Init function to optionally accept pre-defined tools. Ensure the Context type has necessary methods to support tool execution. Add helper methods for common tool registration patterns if needed.\n<info added on 2025-05-15T20:07:31.712Z>\nAfter reviewing the codebase, we should leverage the existing fluent API pattern rather than introducing a new WithTools option. The Server interface already has a Tool() method that provides the correct way to register tools in this codebase.\n\nFor proper integration with server initialization:\n1. Ensure the Context type has all necessary methods to support tool execution, including access to registered tools and execution capabilities\n2. Maintain the existing fluent interface pattern for tool registration (Server.Tool() method)\n3. Add helper methods for common tool registration patterns if needed, while preserving the fluent interface design\n4. Document the recommended approach for registering tools during server setup, with examples showing how to chain Tool() calls during initialization\n5. Verify that tools registered during initialization are properly accessible during request handling\n\nThis approach maintains consistency with the existing codebase patterns and provides a clean API for tool registration during server setup.\n</info added on 2025-05-15T20:07:31.712Z>\n<info added on 2025-05-15T20:26:35.569Z>\nAdd a public RegisterTool method to the Server that wraps the internal registerTool method. Update the server's New or Init function to optionally accept pre-defined tools. Ensure the Context type has necessary methods to support tool execution. Add helper methods for common tool registration patterns if needed.\n\n<info added on 2025-05-15T20:07:31.712Z>\nAfter reviewing the codebase, we should leverage the existing fluent API pattern rather than introducing a new WithTools option. The Server interface already has a Tool() method that provides the correct way to register tools in this codebase.\n\nFor proper integration with server initialization:\n1. Ensure the Context type has all necessary methods to support tool execution, including access to registered tools and execution capabilities\n2. Maintain the existing fluent interface pattern for tool registration (Server.Tool() method)\n3. Add helper methods for common tool registration patterns if needed, while preserving the fluent interface design\n4. Document the recommended approach for registering tools during server setup, with examples showing how to chain Tool() calls during initialization\n5. Verify that tools registered during initialization are properly accessible during request handling\n\nThis approach maintains consistency with the existing codebase patterns and provides a clean API for tool registration during server setup.\n</info added on 2025-05-15T20:07:31.712Z>\n\nWe successfully completed the integration of tool registration with server initialization by making several key improvements:\n\n1. Exported the HandleMessage method from serverImpl by adding it to the Server interface, making it accessible to clients\n2. Updated tests across all MCP specification versions (draft, 2024-11-05, 2025-03-26) to use the exported HandleMessage method directly instead of relying on type assertions\n3. Fixed response parsing issues in the integration test that were preventing proper tool execution verification\n4. Added comprehensive documentation for the HandleMessage method and server configuration options\n5. Set stdio as the default transport constructor in NewServer to provide a better out-of-box experience and eliminate warnings\n6. Added a WithTransport option to allow for custom transport configuration when needed\n7. Fixed various JSON parsing issues in test code that were causing intermittent failures\n\nAll tests now pass successfully, and the tool registration system is fully integrated with server initialization. The implementation maintains the fluent API pattern while providing a clean, well-documented interface for registering and executing tools.\n</info added on 2025-05-15T20:26:35.569Z>",
          "status": "done",
          "testStrategy": "Create integration tests that initialize a server, register tools, and execute them. Test the full flow from registration to execution in various scenarios."
        }
      ]
    },
    {
      "id": 12,
      "title": "Implement Resource Registration and Handling",
      "description": "Implement resource registration and handling functionality in the server package.",
      "details": "Implement resource registration and handling:\n\n```go\n// server/resource.go\npackage server\n\n// ResourceHandler represents a resource handler function\ntype ResourceHandler func(ctx *Context, args interface{}) (interface{}, error)\n\n// Resource represents a registered resource\ntype Resource struct {\n\tPath        string\n\tDescription string\n\tHandler     ResourceHandler\n\tSchema      map[string]interface{}\n\t// Additional fields\n}\n\n// registerResource registers a resource with the server\nfunc (s *Server) registerResource(path, description string, handler ResourceHandler, schema map[string]interface{}) *Server {\n\t// Implementation\n\treturn s\n}\n\n// handleResource handles a resource request\nfunc (s *Server) handleResource(ctx *Context, path string, args map[string]interface{}) (interface{}, error) {\n\t// Implementation\n}\n```\n\nImplement path parameter extraction:\n\n```go\n// Extract path parameters from a URL path\nfunc extractPathParams(pattern, path string) (map[string]string, bool) {\n\t// Parse pattern and path to extract parameters\n\t// Return parameters and whether the path matches the pattern\n}\n\n// Convert path parameters to struct fields\nfunc convertPathParams(params map[string]string, args map[string]interface{}, paramType reflect.Type) (interface{}, error) {\n\t// Convert path parameters to the appropriate struct fields\n}\n```",
      "testStrategy": "Create unit tests for resource registration with various handler signatures. Test resource handling with valid and invalid paths. Test path parameter extraction and conversion. Test error handling for missing or invalid resources.",
      "priority": "high",
      "dependencies": [
        10
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Implement Prompt Registration and Handling",
      "description": "Implement prompt registration and handling functionality in the server package.",
      "details": "Implement prompt registration and handling:\n\n```go\n// server/prompt.go\npackage server\n\n// PromptTemplate represents a prompt template\ntype PromptTemplate struct {\n\tRole    string\n\tContent string\n}\n\n// Prompt represents a registered prompt\ntype Prompt struct {\n\tName        string\n\tDescription string\n\tTemplates   []PromptTemplate\n\tSchema      map[string]interface{}\n\t// Additional fields\n}\n\n// system creates a system prompt template\nfunc system(content string) PromptTemplate {\n\treturn PromptTemplate{Role: \"system\", Content: content}\n}\n\n// user creates a user prompt template\nfunc user(content string) PromptTemplate {\n\treturn PromptTemplate{Role: \"user\", Content: content}\n}\n\n// assistant creates an assistant prompt template\nfunc assistant(content string) PromptTemplate {\n\treturn PromptTemplate{Role: \"assistant\", Content: content}\n}\n\n// registerPrompt registers a prompt with the server\nfunc (s *Server) registerPrompt(name, description string, templates []PromptTemplate) *Server {\n\t// Implementation\n\treturn s\n}\n\n// handlePrompt handles a prompt request\nfunc (s *Server) handlePrompt(ctx *Context, name string, args map[string]interface{}) (interface{}, error) {\n\t// Implementation\n}\n```\n\nImplement template variable substitution:\n\n```go\n// Substitute variables in a template\nfunc substituteVariables(template string, vars map[string]interface{}) (string, error) {\n\t// Replace {{variable}} with the corresponding value\n}\n```",
      "testStrategy": "Create unit tests for prompt registration with various templates. Test prompt handling with valid and invalid arguments. Test template variable substitution. Test error handling for missing or invalid prompts.",
      "priority": "medium",
      "dependencies": [
        10
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "Implement Transport Interface",
      "description": "Define the transport interface and implement common transport functionality.",
      "details": "Define the transport interface:\n\n```go\n// transport/transport.go\npackage transport\n\n// Transport represents a transport layer for MCP communication\ntype Transport interface {\n\t// Initialize initializes the transport\n\tInitialize() error\n\t\n\t// Start starts the transport\n\tStart() error\n\t\n\t// Stop stops the transport\n\tStop() error\n\t\n\t// Send sends a message\n\tSend(message []byte) error\n\t\n\t// Receive receives a message\n\tReceive() ([]byte, error)\n\t\n\t// SetMessageHandler sets the message handler\n\tSetMessageHandler(handler MessageHandler)\n}\n\n// MessageHandler represents a function that handles incoming messages\ntype MessageHandler func(message []byte) ([]byte, error)\n\n// BaseTransport provides common transport functionality\ntype BaseTransport struct {\n\thandler MessageHandler\n\t// Additional fields\n}\n\n// SetMessageHandler sets the message handler\nfunc (t *BaseTransport) SetMessageHandler(handler MessageHandler) {\n\tt.handler = handler\n}\n\n// HandleMessage handles an incoming message\nfunc (t *BaseTransport) HandleMessage(message []byte) ([]byte, error) {\n\tif t.handler == nil {\n\t\treturn nil, errors.New(\"no message handler set\")\n\t}\n\treturn t.handler(message)\n}\n```",
      "testStrategy": "Create unit tests for the base transport functionality. Test message handling with various message types. Test error handling for missing handlers.",
      "priority": "high",
      "dependencies": [
        5
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 15,
      "title": "Implement Stdio Transport",
      "description": "Implement the Standard I/O transport in the transport/stdio package.",
      "details": "Implement the Standard I/O transport:\n\n```go\n// transport/stdio/stdio.go\npackage stdio\n\n// Transport implements the transport.Transport interface for Standard I/O\ntype Transport struct {\n\ttransport.BaseTransport\n\treader *bufio.Reader\n\twriter *bufio.Writer\n\tdone   chan struct{}\n\t// Additional fields\n}\n\n// NewTransport creates a new Standard I/O transport\nfunc NewTransport() *Transport {\n\treturn &Transport{\n\t\treader: bufio.NewReader(os.Stdin),\n\t\twriter: bufio.NewWriter(os.Stdout),\n\t\tdone:   make(chan struct{}),\n\t}\n}\n\n// Initialize initializes the transport\nfunc (t *Transport) Initialize() error {\n\t// Implementation\n}\n\n// Start starts the transport\nfunc (t *Transport) Start() error {\n\t// Start a goroutine to read from stdin\n\tgo t.readLoop()\n\treturn nil\n}\n\n// Stop stops the transport\nfunc (t *Transport) Stop() error {\n\t// Signal the read loop to stop\n\tclose(t.done)\n\treturn nil\n}\n\n// Send sends a message\nfunc (t *Transport) Send(message []byte) error {\n\t// Write the message to stdout\n\t_, err := t.writer.Write(message)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn t.writer.Flush()\n}\n\n// Receive is not used in the stdio transport\nfunc (t *Transport) Receive() ([]byte, error) {\n\treturn nil, errors.New(\"not implemented\")\n}\n\n// readLoop reads messages from stdin\nfunc (t *Transport) readLoop() {\n\t// Read messages from stdin and pass them to the handler\n}\n```",
      "testStrategy": "Create unit tests for the stdio transport. Test initialization, starting, and stopping. Test sending messages. Test the read loop with mock stdin/stdout. Test error handling for I/O errors.",
      "priority": "high",
      "dependencies": [
        14
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 16,
      "title": "Implement WebSocket Transport",
      "description": "Implement the WebSocket transport in the transport/ws package using the gobwas WebSocket library.",
      "status": "done",
      "dependencies": [
        14
      ],
      "priority": "medium",
      "details": "Implement the WebSocket transport using the gobwas WebSocket library (github.com/gobwas/ws):\n\n```go\n// transport/ws/ws.go\npackage ws\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gobwas/ws\"\n\t\"github.com/gobwas/ws/wsutil\"\n)\n\n// Transport implements the transport.Transport interface for WebSocket\ntype Transport struct {\n\ttransport.BaseTransport\n\taddr     string\n\tserver   *http.Server\n\tconns    map[*ws.Conn]bool\n\tconnsMu  sync.Mutex\n\t// Additional fields\n}\n\n// NewTransport creates a new WebSocket transport\nfunc NewTransport(addr string) *Transport {\n\treturn &Transport{\n\t\taddr:  addr,\n\t\tconns: make(map[*ws.Conn]bool),\n\t}\n}\n\n// Initialize initializes the transport\nfunc (t *Transport) Initialize() error {\n\t// Implementation\n}\n\n// Start starts the transport\nfunc (t *Transport) Start() error {\n\t// Start the WebSocket server\n\tt.server = &http.Server{Addr: t.addr, Handler: t}\n\tgo t.server.ListenAndServe()\n\treturn nil\n}\n\n// Stop stops the transport\nfunc (t *Transport) Stop() error {\n\t// Stop the WebSocket server\n\treturn t.server.Shutdown(context.Background())\n}\n\n// Send sends a message to all connected clients\nfunc (t *Transport) Send(message []byte) error {\n\t// Send the message to all connected clients using wsutil.WriteMessage\n\tt.connsMu.Lock()\n\tdefer t.connsMu.Unlock()\n\t\n\tfor conn := range t.conns {\n\t\t// Use wsutil.WriteMessage to send data\n\t\terr := wsutil.WriteMessage(conn, ws.StateServerSide, ws.OpText, message)\n\t\tif err != nil {\n\t\t\t// Handle error, possibly remove connection\n\t\t}\n\t}\n\treturn nil\n}\n\n// Receive is not used in the server-side WebSocket transport\nfunc (t *Transport) Receive() ([]byte, error) {\n\treturn nil, errors.New(\"not implemented for server-side transport\")\n}\n\n// ServeHTTP implements http.Handler\nfunc (t *Transport) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// Upgrade the HTTP connection to a WebSocket connection using gobwas/ws\n\tconn, _, _, err := ws.UpgradeHTTP(r, w)\n\tif err != nil {\n\t\t// Handle error\n\t\treturn\n\t}\n\t\n\t// Register the new connection\n\tt.connsMu.Lock()\n\tt.conns[conn] = true\n\tt.connsMu.Unlock()\n\t\n\t// Handle incoming messages in a goroutine\n\tgo func() {\n\t\tdefer func() {\n\t\t\tconn.Close()\n\t\t\tt.connsMu.Lock()\n\t\t\tdelete(t.conns, conn)\n\t\t\tt.connsMu.Unlock()\n\t\t}()\n\t\t\n\t\tfor {\n\t\t\t// Read messages using wsutil.ReadClientMessage\n\t\t\tmsg, op, err := wsutil.ReadClientData(conn)\n\t\t\tif err != nil {\n\t\t\t\t// Handle error, break the loop\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t\n\t\t\t// Process the message based on opcode\n\t\t\tswitch op {\n\t\t\tcase ws.OpText, ws.OpBinary:\n\t\t\t\t// Handle the message by notifying subscribers\n\t\t\t\tt.NotifySubscribers(msg)\n\t\t\tcase ws.OpClose:\n\t\t\t\t// Handle close message\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n}\n```\n\nAlso implement a client-side WebSocket transport that can connect to a WebSocket server:\n\n```go\n// transport/ws/client.go\npackage ws\n\nimport (\n\t\"context\"\n\t\"sync\"\n\n\t\"github.com/gobwas/ws\"\n\t\"github.com/gobwas/ws/wsutil\"\n)\n\n// ClientTransport implements a client-side WebSocket transport\ntype ClientTransport struct {\n\ttransport.BaseTransport\n\turl      string\n\tconn     *ws.Conn\n\tconnMu   sync.Mutex\n\treadChan chan []byte\n\terrChan  chan error\n\tctx      context.Context\n\tcancel   context.CancelFunc\n}\n\n// NewClientTransport creates a new client-side WebSocket transport\nfunc NewClientTransport(url string) *ClientTransport {\n\tctx, cancel := context.WithCancel(context.Background())\n\treturn &ClientTransport{\n\t\turl:      url,\n\t\treadChan: make(chan []byte, 100),\n\t\terrChan:  make(chan error, 1),\n\t\tctx:      ctx,\n\t\tcancel:   cancel,\n\t}\n}\n\n// Initialize connects to the WebSocket server\nfunc (t *ClientTransport) Initialize() error {\n\t// Connect to the WebSocket server\n\tconn, _, _, err := ws.Dial(context.Background(), t.url)\n\tif err != nil {\n\t\treturn err\n\t}\n\t\n\tt.connMu.Lock()\n\tt.conn = conn\n\tt.connMu.Unlock()\n\t\n\t// Start reading messages\n\tgo t.readLoop()\n\t\n\treturn nil\n}\n\n// Start is a no-op for client transport as initialization handles connection\nfunc (t *ClientTransport) Start() error {\n\treturn nil\n}\n\n// Stop closes the WebSocket connection\nfunc (t *ClientTransport) Stop() error {\n\tt.cancel()\n\tt.connMu.Lock()\n\tdefer t.connMu.Unlock()\n\t\n\tif t.conn != nil {\n\t\treturn t.conn.Close()\n\t}\n\treturn nil\n}\n\n// Send sends a message to the WebSocket server\nfunc (t *ClientTransport) Send(message []byte) error {\n\tt.connMu.Lock()\n\tdefer t.connMu.Unlock()\n\t\n\tif t.conn == nil {\n\t\treturn errors.New(\"not connected\")\n\t}\n\t\n\treturn wsutil.WriteClientMessage(t.conn, ws.OpText, message)\n}\n\n// Receive receives a message from the WebSocket server\nfunc (t *ClientTransport) Receive() ([]byte, error) {\n\tselect {\n\tcase msg := <-t.readChan:\n\t\treturn msg, nil\n\tcase err := <-t.errChan:\n\t\treturn nil, err\n\tcase <-t.ctx.Done():\n\t\treturn nil, errors.New(\"transport stopped\")\n\t}\n}\n\n// readLoop continuously reads messages from the WebSocket connection\nfunc (t *ClientTransport) readLoop() {\n\tfor {\n\t\tselect {\n\t\tcase <-t.ctx.Done():\n\t\t\treturn\n\t\tdefault:\n\t\t\tt.connMu.Lock()\n\t\t\tconn := t.conn\n\t\t\tt.connMu.Unlock()\n\t\t\t\n\t\t\tif conn == nil {\n\t\t\t\tt.errChan <- errors.New(\"not connected\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\t\n\t\t\tmsg, op, err := wsutil.ReadServerData(conn)\n\t\t\tif err != nil {\n\t\t\t\tt.errChan <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\t\n\t\t\tswitch op {\n\t\t\tcase ws.OpText, ws.OpBinary:\n\t\t\t\tt.readChan <- msg\n\t\t\t\t// Also notify subscribers\n\t\t\t\tt.NotifySubscribers(msg)\n\t\t\tcase ws.OpClose:\n\t\t\t\tt.errChan <- errors.New(\"connection closed by server\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n```",
      "testStrategy": "Create unit tests for both the server and client WebSocket transports:\n\n1. Server-side WebSocket transport tests:\n   - Test initialization, starting, and stopping\n   - Test sending messages to connected clients\n   - Test connection handling (adding/removing connections)\n   - Test error handling for connection errors\n   - Test message processing and subscriber notification\n\n2. Client-side WebSocket transport tests:\n   - Test connecting to a WebSocket server\n   - Test sending messages to the server\n   - Test receiving messages from the server\n   - Test error handling for connection issues\n   - Test proper cleanup on stop\n\n3. Integration tests:\n   - Test bidirectional communication between client and server\n   - Test multiple clients connecting to a single server\n   - Test reconnection behavior\n\nUse a test WebSocket server for client tests and mock connections where appropriate.",
      "subtasks": [
        {
          "id": "16.1",
          "title": "Implement server-side WebSocket transport",
          "status": "done",
          "description": "Implement the server-side WebSocket transport using gobwas/ws library with proper connection handling and message broadcasting."
        },
        {
          "id": "16.2",
          "title": "Implement client-side WebSocket transport",
          "status": "done",
          "description": "Create a client-side WebSocket transport that can connect to a WebSocket server and handle bidirectional communication."
        },
        {
          "id": "16.3",
          "title": "Write tests for server-side transport",
          "status": "done",
          "description": "Create unit tests for the server-side WebSocket transport implementation."
        },
        {
          "id": "16.4",
          "title": "Write tests for client-side transport",
          "status": "done",
          "description": "Create unit tests for the client-side WebSocket transport implementation."
        },
        {
          "id": "16.5",
          "title": "Create integration tests",
          "status": "done",
          "description": "Implement integration tests that verify bidirectional communication between client and server transports."
        }
      ]
    },
    {
      "id": 17,
      "title": "Implement Server-Sent Events Transport",
      "description": "Implement the Server-Sent Events transport in the transport/sse package, supporting both server and client-side functionality according to the EventSource specification.",
      "status": "done",
      "dependencies": [
        14
      ],
      "priority": "medium",
      "details": "Implement the Server-Sent Events transport with both server and client capabilities using Go's standard net/http package:\n\n```go\n// transport/sse/sse.go\npackage sse\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"sync\"\n\t\"bufio\"\n\t\"strings\"\n\t\"time\"\n\t\"fmt\"\n\t\"github.com/yourusername/yourproject/transport\"\n)\n\n// Transport implements the transport.Transport interface for Server-Sent Events\ntype Transport struct {\n\ttransport.BaseTransport\n\t// Server-side fields\n\taddr      string\n\tserver    *http.Server\n\tclients   map[chan []byte]bool\n\tclientsMu sync.Mutex\n\t\n\t// Client-side fields\n\turl        string\n\tclient     *http.Client\n\tconnection *http.Response\n\treader     *bufio.Reader\n\tmessageCh  chan []byte\n\tdoneCh     chan struct{}\n\tisClient   bool\n}\n\n// NewServerTransport creates a new Server-Sent Events transport for server use\nfunc NewServerTransport(addr string) *Transport {\n\treturn &Transport{\n\t\taddr:     addr,\n\t\tclients:  make(map[chan []byte]bool),\n\t\tisClient: false,\n\t}\n}\n\n// NewClientTransport creates a new Server-Sent Events transport for client use\nfunc NewClientTransport(url string) *Transport {\n\treturn &Transport{\n\t\turl:       url,\n\t\tclient:    &http.Client{},\n\t\tmessageCh: make(chan []byte, 100),\n\t\tdoneCh:    make(chan struct{}),\n\t\tisClient:  true,\n\t}\n}\n\n// Initialize initializes the transport\nfunc (t *Transport) Initialize() error {\n\t// Implementation differs based on client/server mode\n\tif t.isClient {\n\t\t// Client-side initialization\n\t\treturn nil\n\t} else {\n\t\t// Server-side initialization\n\t\treturn nil\n\t}\n}\n\n// Start starts the transport\nfunc (t *Transport) Start() error {\n\tif t.isClient {\n\t\t// Start client connection to SSE endpoint\n\t\treq, err := http.NewRequest(\"GET\", t.url, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treq.Header.Set(\"Accept\", \"text/event-stream\")\n\t\treq.Header.Set(\"Cache-Control\", \"no-cache\")\n\t\tresp, err := t.client.Do(req)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif resp.StatusCode != http.StatusOK {\n\t\t\tresp.Body.Close()\n\t\t\treturn errors.New(\"unexpected status code\")\n\t\t}\n\t\tt.connection = resp\n\t\tt.reader = bufio.NewReader(resp.Body)\n\t\t\n\t\t// Start goroutine to process events\n\t\tgo t.processEvents()\n\t\treturn nil\n\t} else {\n\t\t// Start the SSE server\n\t\tt.server = &http.Server{Addr: t.addr, Handler: t}\n\t\tgo t.server.ListenAndServe()\n\t\treturn nil\n\t}\n}\n\n// Stop stops the transport\nfunc (t *Transport) Stop() error {\n\tif t.isClient {\n\t\t// Stop client connection\n\t\tclose(t.doneCh)\n\t\tif t.connection != nil && t.connection.Body != nil {\n\t\t\treturn t.connection.Body.Close()\n\t\t}\n\t\treturn nil\n\t} else {\n\t\t// Stop the SSE server\n\t\treturn t.server.Shutdown(context.Background())\n\t}\n}\n\n// Send sends a message\nfunc (t *Transport) Send(message []byte) error {\n\tif t.isClient {\n\t\t// Client-side Send is not typically used in SSE\n\t\treturn errors.New(\"client cannot send messages in SSE\")\n\t} else {\n\t\t// Send the message to all connected clients\n\t\tt.clientsMu.Lock()\n\t\tdefer t.clientsMu.Unlock()\n\t\t\n\t\tfor clientCh := range t.clients {\n\t\t\tselect {\n\t\t\tcase clientCh <- message:\n\t\t\t\t// Message sent successfully\n\t\t\tdefault:\n\t\t\t\t// Client not receiving, remove it\n\t\t\t\tdelete(t.clients, clientCh)\n\t\t\t\tclose(clientCh)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// Receive receives a message\nfunc (t *Transport) Receive() ([]byte, error) {\n\tif t.isClient {\n\t\t// Client receives messages from the SSE server\n\t\tselect {\n\t\tcase msg := <-t.messageCh:\n\t\t\treturn msg, nil\n\t\tcase <-t.doneCh:\n\t\t\treturn nil, errors.New(\"transport closed\")\n\t\t}\n\t} else {\n\t\t// Server-side Receive is not used in SSE\n\t\treturn nil, errors.New(\"not implemented for server\")\n\t}\n}\n\n// ServeHTTP implements http.Handler for server-side SSE\nfunc (t *Transport) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// Set up SSE headers\n\tflusher, ok := w.(http.Flusher)\n\tif !ok {\n\t\thttp.Error(w, \"Streaming not supported\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\t\n\tw.Header().Set(\"Content-Type\", \"text/event-stream\")\n\tw.Header().Set(\"Cache-Control\", \"no-cache\")\n\tw.Header().Set(\"Connection\", \"keep-alive\")\n\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\t\n\t// Create a channel for this client\n\tclientChan := make(chan []byte, 100)\n\t\n\t// Register the client\n\tt.clientsMu.Lock()\n\tt.clients[clientChan] = true\n\tt.clientsMu.Unlock()\n\t\n\t// Remove client when connection is closed\n\tdefer func() {\n\t\tt.clientsMu.Lock()\n\t\tdelete(t.clients, clientChan)\n\t\tclose(clientChan)\n\t\tt.clientsMu.Unlock()\n\t}()\n\t\n\t// Send events to client\n\tfor {\n\t\tselect {\n\t\tcase msg, ok := <-clientChan:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// Format as SSE event\n\t\t\tfmt.Fprintf(w, \"data: %s\\n\\n\", msg)\n\t\t\tflusher.Flush()\n\t\tcase <-r.Context().Done():\n\t\t\t// Client disconnected\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// processEvents handles the client-side event processing\nfunc (t *Transport) processEvents() {\n\tfor {\n\t\tselect {\n\t\tcase <-t.doneCh:\n\t\t\treturn\n\t\tdefault:\n\t\t\tline, err := t.reader.ReadString('\\n')\n\t\t\tif err != nil {\n\t\t\t\t// Handle reconnection logic here\n\t\t\t\ttime.Sleep(3 * time.Second)\n\t\t\t\tt.Start()\n\t\t\t\treturn\n\t\t\t}\n\t\t\t\n\t\t\tline = strings.TrimSpace(line)\n\t\t\tif line == \"\" {\n\t\t\t\t// End of event\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t\n\t\t\tif strings.HasPrefix(line, \"data: \") {\n\t\t\t\tdata := strings.TrimPrefix(line, \"data: \")\n\t\t\t\tselect {\n\t\t\t\tcase t.messageCh <- []byte(data):\n\t\t\t\t\t// Message sent to channel\n\t\t\t\tdefault:\n\t\t\t\t\t// Channel full, discard message\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```",
      "testStrategy": "Create unit tests for the SSE transport covering both client and server functionality:\n\n1. Server-side tests:\n   - Test initialization, starting, and stopping the server\n   - Test sending messages to connected clients\n   - Test client connection handling and disconnection\n   - Test error handling for connection errors\n   - Test proper header setting for SSE connections\n\n2. Client-side tests:\n   - Test connecting to an SSE endpoint\n   - Test receiving events from the server\n   - Test reconnection logic when connection is lost\n   - Test parsing of different event formats according to EventSource specification\n   - Test error handling for connection issues\n   - Test proper header setting for SSE client requests\n\n3. Integration tests:\n   - Test end-to-end communication between a client and server using the SSE transport\n   - Test persistent connection handling\n   - Test multiple clients connecting to a single server\n   - Test server broadcasting to multiple clients\n\n4. Performance tests:\n   - Test handling of high message volumes\n   - Test connection stability over time",
      "subtasks": [
        {
          "id": "17.1",
          "title": "Implement SSE server-side functionality",
          "description": "Implement the server-side of the SSE transport, including client connection handling, message broadcasting, and proper HTTP header management.",
          "status": "done"
        },
        {
          "id": "17.2",
          "title": "Implement SSE client-side functionality",
          "description": "Implement the client-side of the SSE transport, including connection establishment, event parsing according to EventSource specification, and reconnection logic.",
          "status": "done"
        },
        {
          "id": "17.3",
          "title": "Create unit tests for server-side functionality",
          "description": "Develop comprehensive unit tests for the server-side SSE implementation, testing connection handling, message broadcasting, and error scenarios.",
          "status": "done"
        },
        {
          "id": "17.4",
          "title": "Create unit tests for client-side functionality",
          "description": "Develop comprehensive unit tests for the client-side SSE implementation, testing event parsing, reconnection logic, and error handling.",
          "status": "done"
        },
        {
          "id": "17.5",
          "title": "Create integration tests for SSE transport",
          "description": "Develop integration tests that verify end-to-end communication between SSE clients and servers, including multiple client scenarios and persistent connection handling.",
          "status": "done"
        }
      ]
    },
    {
      "id": 18,
      "title": "Implement HTTP Transport",
      "description": "Implement the HTTP transport in the transport/http package, supporting JSON-RPC protocol.",
      "status": "done",
      "dependencies": [
        14
      ],
      "priority": "medium",
      "details": "Implement the HTTP transport using Go's standard net/http package:\n\n```go\n// transport/http/http.go\npackage http\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net/http\"\n\t\"io/ioutil\"\n\t\"encoding/json\"\n\n\t\"github.com/yourusername/yourproject/transport\"\n)\n\n// Transport implements the transport.Transport interface for HTTP\ntype Transport struct {\n\ttransport.BaseTransport\n\taddr     string\n\tserver   *http.Server\n\tasyncHandlers map[string]transport.AsyncMessageHandler\n}\n\n// NewTransport creates a new HTTP transport\nfunc NewTransport(addr string) *Transport {\n\treturn &Transport{\n\t\taddr: addr,\n\t\tasyncHandlers: make(map[string]transport.AsyncMessageHandler),\n\t}\n}\n\n// Initialize initializes the transport\nfunc (t *Transport) Initialize() error {\n\t// Implementation\n\treturn nil\n}\n\n// Start starts the transport\nfunc (t *Transport) Start() error {\n\t// Start the HTTP server\n\tt.server = &http.Server{Addr: t.addr, Handler: t}\n\tgo t.server.ListenAndServe()\n\treturn nil\n}\n\n// Stop stops the transport\nfunc (t *Transport) Stop() error {\n\t// Stop the HTTP server\n\treturn t.server.Shutdown(context.Background())\n}\n\n// Send is not used in the HTTP transport\nfunc (t *Transport) Send(message []byte) error {\n\treturn errors.New(\"not implemented for HTTP transport - use HTTP responses instead\")\n}\n\n// Receive is not used in the HTTP transport\nfunc (t *Transport) Receive() ([]byte, error) {\n\treturn nil, errors.New(\"not implemented for HTTP transport - use HTTP requests instead\")\n}\n\n// RegisterAsyncHandler registers a handler for asynchronous message processing\nfunc (t *Transport) RegisterAsyncHandler(method string, handler transport.AsyncMessageHandler) {\n\tt.asyncHandlers[method] = handler\n}\n\n// ServeHTTP implements http.Handler\nfunc (t *Transport) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// Only accept POST requests for JSON-RPC\n\tif r.Method != http.MethodPost {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\t// Read request body\n\tbody, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer r.Body.Close()\n\n\t// Parse JSON-RPC request\n\tvar jsonRPCRequest struct {\n\t\tJsonrpc string      `json:\"jsonrpc\"`\n\t\tMethod  string      `json:\"method\"`\n\t\tParams  interface{} `json:\"params,omitempty\"`\n\t\tId      interface{} `json:\"id,omitempty\"`\n\t}\n\n\tif err := json.Unmarshal(body, &jsonRPCRequest); err != nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Validate JSON-RPC version\n\tif jsonRPCRequest.JsonRPC != \"2.0\" {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\t// Handle the request based on whether it's a notification (async) or a regular request (sync)\n\tif jsonRPCRequest.Id == nil {\n\t\t// Asynchronous notification\n\t\tif handler, ok := t.asyncHandlers[jsonRPCRequest.Method]; ok {\n\t\t\tgo handler(body)\n\t\t\tw.WriteHeader(http.StatusAccepted)\n\t\t\treturn\n\t\t}\n\t} else {\n\t\t// Synchronous request\n\t\tif t.Handler != nil {\n\t\t\tresponse, err := t.Handler(body)\n\t\t\tif err != nil {\n\t\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\tw.Write(response)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Method not found\n\tw.WriteHeader(http.StatusNotFound)\n}\n```",
      "testStrategy": "Create unit tests for the HTTP transport:\n1. Test initialization, starting, and stopping of the HTTP server\n2. Test JSON-RPC request handling for both synchronous and asynchronous patterns\n3. Test proper handling of JSON-RPC protocol elements (method, params, id)\n4. Test error handling for malformed requests, invalid JSON, and method not found scenarios\n5. Test HTTP-specific behaviors like status codes and headers\n6. Mock the handler to verify correct message passing\n7. Test concurrent request handling",
      "subtasks": [
        {
          "id": "18.1",
          "title": "Implement basic HTTP transport structure",
          "status": "done"
        },
        {
          "id": "18.2",
          "title": "Implement JSON-RPC request parsing",
          "status": "done"
        },
        {
          "id": "18.3",
          "title": "Implement synchronous request handling",
          "status": "done"
        },
        {
          "id": "18.4",
          "title": "Implement asynchronous notification handling",
          "status": "done"
        },
        {
          "id": "18.5",
          "title": "Implement proper error handling and status codes",
          "status": "done"
        },
        {
          "id": "18.6",
          "title": "Write unit tests for HTTP transport",
          "status": "done"
        }
      ]
    },
    {
      "id": 19,
      "title": "Implement Transport Selection in Server",
      "description": "Implement transport selection in the server package using fluent methods.",
      "details": "Implement transport selection methods in the server package:\n\n```go\n// server/server.go\n\n// AsStdio configures the server to use the Standard I/O transport\nfunc (s *Server) AsStdio() *Server {\n\ts.transport = stdio.NewTransport()\n\treturn s\n}\n\n// AsWebsocket configures the server to use the WebSocket transport\nfunc (s *Server) AsWebsocket(addr string) *Server {\n\ts.transport = ws.NewTransport(addr)\n\treturn s\n}\n\n// AsSSE configures the server to use the Server-Sent Events transport\nfunc (s *Server) AsSSE(addr string) *Server {\n\ts.transport = sse.NewTransport(addr)\n\treturn s\n}\n\n// AsHTTP configures the server to use the HTTP transport\nfunc (s *Server) AsHTTP(addr string) *Server {\n\ts.transport = http.NewTransport(addr)\n\treturn s\n}\n```\n\nUpdate the Run method to initialize and start the selected transport:\n\n```go\n// Run starts the server\nfunc (s *Server) Run() error {\n\tif s.transport == nil {\n\t\t// Default to stdio if no transport is selected\n\t\ts.transport = stdio.NewTransport()\n\t}\n\t\n\t// Initialize the transport\n\terr := s.transport.Initialize()\n\tif err != nil {\n\t\treturn err\n\t}\n\t\n\t// Set the message handler\n\ts.transport.SetMessageHandler(s.handleMessage)\n\t\n\t// Start the transport\n\treturn s.transport.Start()\n}\n\n// handleMessage handles incoming messages\nfunc (s *Server) handleMessage(message []byte) ([]byte, error) {\n\t// Parse the message\n\t// Handle the message based on its type\n\t// Return the response\n}\n```",
      "testStrategy": "Create unit tests for transport selection methods. Test that each method correctly configures the server with the appropriate transport. Test the Run method with different transports. Test error handling for transport initialization and starting.",
      "priority": "high",
      "dependencies": [
        10,
        15,
        16,
        17,
        18
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 20,
      "title": "Implement Client Core",
      "description": "Implement the core client functionality in the client package, including the client struct and basic methods.",
      "status": "done",
      "dependencies": [
        5,
        6,
        7,
        8,
        9
      ],
      "priority": "high",
      "details": "The client core functionality has been implemented in the client package, including:\n\n1. Client struct and initialization with options pattern\n2. Protocol version detection\n3. Basic API methods:\n   - GetResource\n   - CallTool\n   - GetPrompt\n   - Root resource management\n\nImplemented code structure:\n\n```go\n// client/client.go\npackage client\n\n// Client represents an MCP client\ntype Client struct {\n\turl           string\n\ttransport     Transport\n\tlogger        *slog.Logger\n\tversionDetector *mcp.VersionDetector\n\t// Additional fields\n}\n\n// NewClient creates a new MCP client\nfunc NewClient(url string, options ...Option) *Client {\n\t// Implementation\n}\n\n// Option represents a client configuration option\ntype Option func(*Client)\n\n// WithLogger sets the client's logger\nfunc WithLogger(logger *slog.Logger) Option {\n\t// Implementation\n}\n\n// CallTool calls a tool on the server\nfunc (c *Client) CallTool(name string, args map[string]interface{}) (interface{}, error) {\n\t// Implementation\n}\n\n// GetResource gets a resource from the server\nfunc (c *Client) GetResource(path string) (interface{}, error) {\n\t// Implementation\n}\n\n// GetPrompt gets a prompt from the server\nfunc (c *Client) GetPrompt(name string, args map[string]interface{}) (interface{}, error) {\n\t// Implementation\n}\n\n// GetRoot gets the root resource from the server\nfunc (c *Client) GetRoot() (interface{}, error) {\n\t// Implementation\n}\n```\n\nImplemented transport interface:\n\n```go\n// client/transport.go\npackage client\n\n// Transport represents a transport layer for client communication\ntype Transport interface {\n\t// Connect connects to the server\n\tConnect() error\n\t\n\t// Disconnect disconnects from the server\n\tDisconnect() error\n\t\n\t// Send sends a message and waits for a response\n\tSend(message []byte) ([]byte, error)\n}\n```\n\nThe client structure follows the design principles from the PRD with a clean, intuitive API. Only specific improvements to JSON-RPC handling and some edge cases may remain for future refinement.",
      "testStrategy": "Unit tests have been created for client creation and configuration. The basic client methods have been tested with mock transports. Error handling for connection and communication errors has been verified.",
      "subtasks": [
        {
          "id": 20.1,
          "title": "Potential future improvements",
          "description": "Consider future improvements to the client core:",
          "details": "1. Enhance JSON-RPC error handling for more specific error types\n2. Add additional edge case handling\n3. Consider performance optimizations for high-volume requests",
          "status": "pending"
        }
      ]
    },
    {
      "id": 21,
      "title": "Implement Client Transports",
      "description": "Implement client-side transports for different protocols.",
      "status": "done",
      "dependencies": [
        20
      ],
      "priority": "high",
      "details": "Client-side transports have been successfully implemented for different protocols:\n\n```go\n// client/stdio/stdio.go\npackage stdio\n\n// Transport implements the client.Transport interface for Standard I/O\ntype Transport struct {\n\treader *bufio.Reader\n\twriter *bufio.Writer\n\t// Additional fields\n}\n\n// NewTransport creates a new Standard I/O transport\nfunc NewTransport() *Transport {\n\treturn &Transport{\n\t\treader: bufio.NewReader(os.Stdin),\n\t\twriter: bufio.NewWriter(os.Stdout),\n\t}\n}\n\n// Connect connects to the server\nfunc (t *Transport) Connect() error {\n\t// No-op for stdio\n\treturn nil\n}\n\n// Disconnect disconnects from the server\nfunc (t *Transport) Disconnect() error {\n\t// No-op for stdio\n\treturn nil\n}\n\n// Send sends a message and waits for a response\nfunc (t *Transport) Send(message []byte) ([]byte, error) {\n\t// Write the message to stdout\n\t_, err := t.writer.Write(message)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = t.writer.Flush()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t\n\t// Read the response from stdin\n\tresponse, err := t.reader.ReadBytes('\\n')\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t\n\treturn response, nil\n}\n```\n\nSimilar transports have been implemented for WebSocket, SSE, and HTTP. Transport auto-detection based on URL has been implemented:\n\n```go\n// client/client.go\n\n// detectTransport detects the appropriate transport based on the URL\nfunc detectTransport(url string) (Transport, error) {\n\tif strings.HasPrefix(url, \"ws://\") || strings.HasPrefix(url, \"wss://\") {\n\t\treturn ws.NewTransport(url), nil\n\t} else if strings.HasPrefix(url, \"http://\") || strings.HasPrefix(url, \"https://\") {\n\t\t// Check if the server supports SSE or use HTTP\n\t\t// Implementation\n\t} else if url == \"stdio://\" {\n\t\treturn stdio.NewTransport(), nil\n\t}\n\t\n\treturn nil, fmt.Errorf(\"unsupported URL scheme: %s\", url)\n}\n```\n\nAll client-side transports have been implemented to match their server-side counterparts, and transport selection is working correctly based on URL or configuration options.",
      "testStrategy": "Unit tests have been created for each client transport. Tests cover connection, disconnection, and message sending functionality. Transport auto-detection has been tested with various URLs. Error handling for connection and communication errors has been verified.",
      "subtasks": [
        {
          "id": 21.1,
          "title": "Potential future optimizations",
          "description": "While the core implementation is complete, future optimizations could include: improved error handling with more specific error types, connection pooling for HTTP/WebSocket transports, automatic reconnection strategies, and performance optimizations for high-throughput scenarios.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 22,
      "title": "Implement Root Package API",
      "description": "Implement the root package API in gomcp.go to provide a single entry point for all functionality.",
      "details": "Implement the root package API in gomcp.go:\n\n```go\n// gomcp.go\npackage gomcp\n\n// Import all required packages\nimport (\n\t\"github.com/localrivet/gomcp/client\"\n\t\"github.com/localrivet/gomcp/server\"\n\t\"github.com/localrivet/gomcp/util/slog\"\n\t// Additional imports\n)\n\n// NewServer creates a new MCP server\nfunc NewServer(name string, options ...server.Option) *server.Server {\n\treturn server.NewServer(name, options...)\n}\n\n// NewClient creates a new MCP client\nfunc NewClient(url string, options ...client.Option) *client.Client {\n\treturn client.NewClient(url, options...)\n}\n\n// WithLogger creates a server or client option with the given logger\nfunc WithLogger(logger *slog.Logger) interface{} {\n\treturn struct {\n\t\tserver.Option\n\t\tclient.Option\n\t}{\n\t\tserver.WithLogger(logger),\n\t\tclient.WithLogger(logger),\n\t}\n}\n\n// NewLogger creates a new logger with the given options\nfunc NewLogger(options ...slog.Option) *slog.Logger {\n\treturn slog.NewLogger(options...)\n}\n\n// LogToFile creates a logger option to log to a file\nfunc LogToFile(dir, prefix string) slog.Option {\n\treturn slog.WithFileOutput(dir, prefix)\n}\n\n// LogLevel creates a logger option to set the log level\nfunc LogLevel(level string) slog.Option {\n\treturn slog.WithLevel(level)\n}\n\n// LogConfig creates a logger configuration\nfunc LogConfig(name string, options ...slog.Option) *slog.Config {\n\treturn slog.NewConfig(name, options...)\n}\n\n// LogConfigOpt creates a server or client option with the given logger configuration\nfunc LogConfigOpt(config *slog.Config) interface{} {\n\tlogger := slog.NewLoggerFromConfig(config)\n\treturn WithLogger(logger)\n}\n\n// Export server helper functions\nfunc system(content string) server.PromptTemplate {\n\treturn server.System(content)\n}\n\nfunc user(content string) server.PromptTemplate {\n\treturn server.User(content)\n}\n\nfunc assistant(content string) server.PromptTemplate {\n\treturn server.Assistant(content)\n}\n```",
      "testStrategy": "Create unit tests for the root package API. Test server and client creation with various options. Test logger creation and configuration. Test that all exported functions work correctly.",
      "priority": "high",
      "dependencies": [
        10,
        11,
        12,
        13,
        19,
        20,
        21
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 23,
      "title": "Implement Error Handling and Types",
      "description": "Implement error handling and error types for the library.",
      "details": "Implement error handling and error types:\n\n```go\n// errors.go\npackage gomcp\n\n// Error represents a GOMCP error\ntype Error struct {\n\tCode    string\n\tMessage string\n\tDetails interface{}\n}\n\n// Error implements the error interface\nfunc (e *Error) Error() string {\n\treturn fmt.Sprintf(\"%s: %s\", e.Code, e.Message)\n}\n\n// NewError creates a new GOMCP error\nfunc NewError(code, message string, details interface{}) *Error {\n\treturn &Error{\n\t\tCode:    code,\n\t\tMessage: message,\n\t\tDetails: details,\n\t}\n}\n\n// Predefined error codes\nconst (\n\tErrInvalidArgument = \"INVALID_ARGUMENT\"\n\tErrNotFound        = \"NOT_FOUND\"\n\tErrInternal        = \"INTERNAL\"\n\tErrUnavailable     = \"UNAVAILABLE\"\n\tErrUnimplemented   = \"UNIMPLEMENTED\"\n\t// Additional error codes\n)\n\n// IsErrorCode checks if an error has a specific code\nfunc IsErrorCode(err error, code string) bool {\n\tif e, ok := err.(*Error); ok {\n\t\treturn e.Code == code\n\t}\n\treturn false\n}\n```\n\nImplement error handling in the server and client packages:\n\n```go\n// server/errors.go\npackage server\n\n// Error handling functions\nfunc invalidArgumentError(message string, details interface{}) *gomcp.Error {\n\treturn gomcp.NewError(gomcp.ErrInvalidArgument, message, details)\n}\n\nfunc notFoundError(message string, details interface{}) *gomcp.Error {\n\treturn gomcp.NewError(gomcp.ErrNotFound, message, details)\n}\n\n// Additional error handling functions\n```\n\n```go\n// client/errors.go\npackage client\n\n// Error handling functions\nfunc transportError(message string, details interface{}) *gomcp.Error {\n\treturn gomcp.NewError(gomcp.ErrUnavailable, message, details)\n}\n\nfunc responseError(message string, details interface{}) *gomcp.Error {\n\treturn gomcp.NewError(gomcp.ErrInternal, message, details)\n}\n\n// Additional error handling functions\n```",
      "testStrategy": "Create unit tests for error creation and handling. Test error codes and messages. Test error checking functions. Test error handling in the server and client packages.",
      "priority": "medium",
      "dependencies": [
        10,
        20
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 24,
      "title": "Implement Comprehensive Examples",
      "description": "Implement comprehensive examples for all major features of the library.",
      "details": "Implement comprehensive examples for all major features:\n\n```go\n// examples/basic_server/main.go\npackage main\n\nimport (\n\t\"github.com/localrivet/gomcp\"\n)\n\nfunc main() {\n\t// Create a server\n\tserver := gomcp.NewServer(\"Example Server\").AsStdio()\n\t\n\t// Add a tool\n\tserver.Tool(\"add\", \"Add two numbers\", func(ctx *server.Context, args struct {\n\t\tX float64 `required:\"true\"`\n\t\tY float64 `required:\"true\"`\n\t}) (float64, error) {\n\t\treturn args.X + args.Y, nil\n\t})\n\t\n\t// Add a resource\n\tserver.Resource(\"users/{id}\", \"Get user information\", func(ctx *server.Context, args struct {\n\t\tID string `path:\"id\"`\n\t}) (map[string]interface{}, error) {\n\t\treturn map[string]interface{}{\n\t\t\t\"id\":   args.ID,\n\t\t\t\"name\": \"Example User\",\n\t\t}, nil\n\t})\n\t\n\t// Add a prompt\n\tserver.Prompt(\"greeting\", \"Greet a user\",\n\t\tgomcp.system(\"You are a helpful assistant for {{service}}.\"),\n\t\tgomcp.user(\"Hello, my name is {{name}}.\"),\n\t)\n\t\n\t// Set the root resource\n\tserver.Root(func(ctx *server.Context) (map[string]interface{}, error) {\n\t\treturn map[string]interface{}{\n\t\t\t\"name\":        \"Example Server\",\n\t\t\t\"version\":     \"1.0.0\",\n\t\t\t\"description\": \"An example MCP server\",\n\t\t}, nil\n\t})\n\t\n\t// Run the server\n\tserver.Run()\n}\n```\n\nImplement additional examples for:\n- Client usage\n- Different transport types\n- Authentication\n- Error handling\n- Advanced tool implementation\n- Advanced resource implementation\n- Prompt implementation\n- Logging configuration",
      "testStrategy": "Ensure all examples compile and run correctly. Test each example with appropriate inputs. Document expected outputs for each example.",
      "priority": "medium",
      "dependencies": [
        22
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 25,
      "title": "Implement Documentation and Tests",
      "description": "Implement comprehensive documentation and tests for the library.",
      "details": "Implement comprehensive documentation:\n\n1. Package documentation:\n```go\n// Package gomcp provides a Go implementation of the Model Context Protocol (MCP).\n//\n// GOMCP is designed to enable seamless integration between Go applications and\n// Large Language Models (LLMs). It provides a simple, intuitive API for creating\n// MCP servers and clients.\n//\n// Basic usage:\n//\n//   // Create a server\n//   server := gomcp.NewServer(\"My Service\").AsStdio()\n//\n//   // Add a tool\n//   server.Tool(\"add\", \"Add two numbers\", func(ctx *server.Context, args struct {\n//     X float64 `required:\"true\"`\n//     Y float64 `required:\"true\"`\n//   }) (float64, error) {\n//     return args.X + args.Y, nil\n//   })\n//\n//   // Run the server\n//   server.Run()\n//\n// For more examples, see the examples directory.\npackage gomcp\n```\n\n2. Function documentation:\n```go\n// NewServer creates a new MCP server with the given name and options.\n//\n// The server provides a fluent interface for configuration:\n//\n//   server := gomcp.NewServer(\"My Service\", gomcp.WithLogger(logger)).\n//     AsStdio().\n//     Tool(\"add\", \"Add two numbers\", addHandler).\n//     Resource(\"users/{id}\", \"Get user information\", getUserHandler).\n//     Prompt(\"greeting\", \"Greet a user\", templates...).\n//     Root(rootHandler)\n//\n// The server supports all MCP specification versions automatically.\nfunc NewServer(name string, options ...server.Option) *server.Server {\n\t// Implementation\n}\n```\n\nImplement comprehensive tests:\n\n1. Unit tests for all packages\n2. Integration tests for server-client communication\n3. Benchmark tests for performance-critical code\n4. Example tests that demonstrate usage\n5. Cross-implementation tests with other MCP implementations",
      "testStrategy": "Ensure all documentation is clear and accurate. Verify that all exported functions, types, and methods are documented. Ensure all tests pass and provide good coverage. Use go test -cover to measure test coverage.",
      "priority": "medium",
      "dependencies": [
        22,
        23,
        24
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Update Package Documentation in gomcp.go",
          "description": "Add comprehensive package-level documentation to gomcp.go with clear examples of usage",
          "details": "Update the gomcp.go file to include comprehensive package documentation that:\n1. Describes the purpose of the library\n2. Explains the Model Context Protocol concepts\n3. Provides basic usage examples for client and server\n4. Links to the MCP specification\n5. References example code in the examples directory",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 25
        },
        {
          "id": 2,
          "title": "Improve Function and Type Documentation in client Package",
          "description": "Ensure all exported functions, types, and methods in the client package have clear, comprehensive documentation",
          "details": "Review and enhance documentation for all exported elements in the client package:\n1. Add comprehensive comments to all exported functions\n2. Document all struct fields with clear descriptions\n3. Add usage examples for key functions like NewClient\n4. Ensure interface documentation explains contract requirements\n5. Include links to related functions and types where appropriate",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 25
        },
        {
          "id": 3,
          "title": "Improve Function and Type Documentation in server Package",
          "description": "Ensure all exported functions, types, and methods in the server package have clear, comprehensive documentation",
          "details": "Review and enhance documentation for all exported elements in the server package:\n1. Add comprehensive comments to all exported functions\n2. Document all struct fields with clear descriptions\n3. Add usage examples for key functions like NewServer\n4. Ensure handler interface documentation explains parameter usage\n5. Include links to related functions and types where appropriate",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 25
        },
        {
          "id": 4,
          "title": "Create Additional Unit Tests for client Package",
          "description": "Implement more comprehensive unit tests for the client package to increase code coverage",
          "details": "Add unit tests for the client package focusing on:\n1. Edge cases in client initialization and configuration\n2. Error handling scenarios for network failures\n3. Protocol version negotiation and compatibility\n4. Resource handling and parsing\n5. Tool calls with various argument types\n6. Sampling functionality\n7. Session management\n\nUse table-driven tests where appropriate to test multiple scenarios efficiently.",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 25
        },
        {
          "id": 5,
          "title": "Create Additional Unit Tests for server Package",
          "description": "Implement more comprehensive unit tests for the server package to increase code coverage",
          "details": "Add unit tests for the server package focusing on:\n1. Server initialization with various configurations\n2. Tool registration and execution\n3. Resource handling and path parameter extraction\n4. Error handling for malformed requests\n5. Session management\n6. Protocol version handling\n7. Concurrent request processing\n\nCreate mock clients to test server responses and behavior under load.",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 25
        },
        {
          "id": 6,
          "title": "Create Integration Tests for Client-Server Communication",
          "description": "Implement end-to-end integration tests that verify proper communication between clients and servers",
          "details": "Create integration tests that:\n1. Start actual server instances\n2. Connect real clients to those servers\n3. Test full request-response cycles for all supported operations\n4. Verify protocol version negotiation works correctly\n5. Test handling of malformed requests and error conditions\n6. Verify proper cleanup and resource release\n7. Test all transport types (stdio, http, websocket, etc.)\n\nThese tests should run as part of the regular test suite but can be tagged to be skipped during quick tests with a flag.",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 25
        },
        {
          "id": 7,
          "title": "Create Example Tests",
          "description": "Create runnable example tests that demonstrate library usage and serve as documentation",
          "details": "Implement example tests using Go's Example test syntax that demonstrate:\n1. Basic client usage\n2. Basic server creation and configuration\n3. Tool implementation and calling\n4. Resource handling\n5. Error handling\n6. Sampling functionality\n7. Full client-server communication examples\n\nThese examples will be displayed in godoc and should be clear enough to serve as standalone documentation.",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 25
        },
        {
          "id": 8,
          "title": "Implement Benchmark Tests",
          "description": "Create benchmark tests for performance-critical components",
          "details": "Design and implement benchmark tests for:\n1. Client-server communication throughput\n2. Protocol message serialization/deserialization\n3. Tool execution performance\n4. Resource handling performance\n5. Connection establishment time\n6. Memory usage patterns\n7. Concurrent request handling\n\nThese benchmarks should provide a baseline for future performance optimization and regression detection.",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 25
        },
        {
          "id": 9,
          "title": "Create Documentation Website Structure",
          "description": "Set up a documentation website structure with key sections for users",
          "details": "Create a documentation website structure with:\n1. A getting started guide\n2. Installation instructions\n3. Basic tutorials for client and server usage\n4. API reference section (generated from code comments)\n5. Examples section showing common usage patterns\n6. Troubleshooting guide\n7. Version compatibility information\n8. MCP specification reference\n\nThis task includes setting up the directory structure and basic template files for documentation content.",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 25
        }
      ]
    },
    {
      "id": 26,
      "title": "Implement Comprehensive Testing Infrastructure for Client Package",
      "description": "Develop a robust testing infrastructure for the client package that includes shared test utilities, mocks, and version compatibility tests across all protocol versions (draft, v20241105, v20250326).",
      "status": "done",
      "dependencies": [
        20
      ],
      "priority": "high",
      "details": "This task involves creating a comprehensive testing infrastructure to ensure the client package functions correctly across all protocol versions. The implementation should include:\n\n1. Create a shared MockTransport implementation:\n   - Implement a configurable MockTransport that can simulate various network conditions\n   - Support recording of requests for verification\n   - Allow for programmatic response configuration\n   - Handle error scenarios and edge cases\n\n2. Develop test utilities for standardized responses:\n   - Create helper functions to generate protocol-compliant responses\n   - Implement factories for common response types\n   - Support all three protocol versions with version-specific response formatting\n   - Utilize the new client/test/jsonrpc package with structured types and builders\n\n3. Implement helper functions for common assertions:\n   - Create assertion utilities for validating request/response pairs\n   - Develop helpers for checking error handling\n   - Implement utilities for verifying correct protocol usage\n   - Leverage the new JSONRPC and RPCError types from the jsonrpc package\n\n4. Build a parameterized test framework:\n   - Create a framework that runs tests across all protocol versions\n   - Support matrix testing with different configuration options\n   - Implement test fixtures that can be reused across test suites\n   - Ensure compatibility with the new jsonrpc package structure\n\n5. Refactor existing tests:\n   - Identify and eliminate duplicated test code\n   - Migrate existing tests to use the new infrastructure\n   - Update tests to use the new JSONRPC and RPCError types\n   - Ensure backward compatibility with existing test cases\n\n6. Documentation:\n   - Document the testing infrastructure with examples\n   - Create guidelines for writing new tests\n   - Include best practices for test coverage\n   - Explain the separation of concerns in the new architecture\n\nThe implementation should focus on maintainability, extensibility, and comprehensive coverage while reducing code duplication across test files. The new dedicated jsonrpc package with types.go and builders.go provides better separation of concerns and cleaner test organization.",
      "testStrategy": "The testing infrastructure itself will be verified through a multi-layered approach:\n\n1. Unit Tests for Infrastructure Components:\n   - Write unit tests for the MockTransport implementation\n   - Test all test utilities and helper functions\n   - Verify the parameterized test framework functions correctly\n   - Ensure the jsonrpc package components work as expected\n\n2. Integration Tests:\n   - Create a sample client implementation that uses the testing infrastructure\n   - Verify that tests can be run across all protocol versions\n   - Ensure that the infrastructure correctly identifies protocol-specific issues\n   - Test the interaction between MockTransport and the jsonrpc package\n\n3. Coverage Analysis:\n   - Measure test coverage of the client package before and after implementation\n   - Ensure critical paths have appropriate test coverage\n   - Identify and address any coverage gaps\n\n4. Code Review Criteria:\n   - Review for elimination of code duplication\n   - Verify that all protocol versions are properly supported\n   - Ensure the infrastructure is extensible for future protocol versions\n   - Check proper usage of the new JSONRPC and RPCError types\n\n5. Documentation Verification:\n   - Review documentation for clarity and completeness\n   - Verify examples work as described\n   - Ensure guidelines are comprehensive\n   - Confirm documentation reflects the new architecture\n\n6. Practical Application:\n   - Apply the testing infrastructure to at least three different client features\n   - Verify that edge cases and error conditions are properly tested\n   - Confirm that protocol version differences are correctly handled\n   - Validate the separation of concerns in real-world test scenarios\n\nThe implementation will be considered complete when all existing tests have been migrated to use the new infrastructure, test coverage has increased, and new tests can be written with significantly less code duplication.",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement MockTransport with Configurable Network Conditions",
          "description": "Create a flexible MockTransport implementation that can simulate various network conditions, record requests, and provide programmatic response configuration.",
          "dependencies": [],
          "details": "Develop a MockTransport class that implements the Transport interface with the following capabilities: 1) Record all requests for later verification, 2) Configure responses programmatically including delays and errors, 3) Simulate network conditions like timeouts and connection drops, 4) Support all protocol versions with appropriate serialization/deserialization, 5) Include methods for assertions and verification of request sequences.\n<info added on 2025-05-16T19:58:20.282Z>\nDevelop a MockTransport class that implements the Transport interface with the following capabilities: 1) Record all requests for later verification, 2) Configure responses programmatically including delays and errors, 3) Simulate network conditions like timeouts and connection drops, 4) Support all protocol versions with appropriate serialization/deserialization, 5) Include methods for assertions and verification of request sequences.\n\nExtend the existing MockTransport implementation in client/test/mocktransport.go with the following enhancements:\n\n1. Network Simulation Features:\n   - Add configurable latency simulation with jitter options\n   - Implement packet loss simulation with customizable loss rates\n   - Add bandwidth limitation capabilities\n   - Create connection degradation simulation (gradually increasing latency)\n\n2. Enhanced Request/Response Recording:\n   - Implement detailed request history with timestamps\n   - Add filtering and query capabilities for recorded requests\n   - Create snapshots of request state for verification points\n\n3. Response Sequence Configuration:\n   - Support for response queues (different responses for sequential calls)\n   - Conditional responses based on request content\n   - Stateful response patterns (changing behavior after X calls)\n\n4. Test Convenience Methods:\n   - Add fluent API for common test scenarios\n   - Create factory methods for standard protocol responses\n   - Implement verification helpers for common assertions\n\n5. Transport Interface Compliance:\n   - Ensure full implementation of all Transport interface methods\n   - Add proper context handling for all operations\n   - Implement protocol version negotiation simulation\n\nMaintain backward compatibility with existing tests while adding these new capabilities.\n</info added on 2025-05-16T19:58:20.282Z>\n<info added on 2025-05-16T19:59:49.212Z>\nThe implementation of the enhanced MockTransport in client/test/mocktransport.go has been completed with the following key features:\n\n1. Comprehensive network simulation capabilities:\n   - Configurable latency with random jitter to simulate real-world network variability\n   - Packet loss simulation with adjustable loss rates\n   - Connection failure simulation for testing error handling\n   - Disconnect after N requests option to test reconnection logic\n\n2. Advanced response handling:\n   - Response queuing with FIFO order for complex interaction testing\n   - Conditional responses based on request content for stateful testing\n   - Probabilistic responses for flakiness testing and edge case detection\n   - Default fallback responses to simplify test setup\n\n3. Request recording and inspection:\n   - Complete request history with timestamps for sequence verification\n   - Request filtering by ID and method for targeted assertions\n   - JSON-RPC request parsing for improved introspection and validation\n\n4. Thread safety:\n   - All operations are protected by a mutex to ensure test reliability\n   - Context-aware operations that respect cancellation for timeout testing\n\n5. Fluent API:\n   - Builder pattern for easy configuration with minimal code\n   - Method chaining for concise test setup\n   - Helper functions for common conditions to reduce boilerplate\n\nThe implementation maintains backward compatibility with existing tests while providing significantly enhanced capabilities for new tests. This MockTransport serves as the foundation for the comprehensive testing infrastructure and enables more thorough testing of client behavior under various network conditions.\n</info added on 2025-05-16T19:59:49.212Z>",
          "status": "done",
          "testStrategy": "Unit test the MockTransport implementation with various configurations to ensure it correctly simulates network conditions and properly records requests."
        },
        {
          "id": 2,
          "title": "Create Test Utilities for Standardized Protocol Responses",
          "description": "Develop helper functions and factories to generate protocol-compliant responses for all supported versions (draft, v20241105, v20250326).",
          "dependencies": [
            1
          ],
          "details": "Implement response factories with the following features: 1) Generate valid responses for all API endpoints, 2) Support version-specific formatting differences, 3) Create helper functions for common response types (success, error, partial), 4) Include utilities for generating edge cases and boundary conditions, 5) Ensure type safety and proper interface adherence.\n\nUtilize the new client/test/jsonrpc package with its structured types and builders:\n- Use the JSONRPC type (renamed from Message) for structured JSON-RPC message representation\n- Leverage the RPCError type (renamed from Error) for standardized error handling\n- Implement builders.go functionality to create test messages with minimal boilerplate\n- Ensure all factories work with the new type system for better type safety\n- Create version-specific response generators that leverage the common structure\n<info added on 2025-05-16T23:14:33.390Z>\nImplement response factories with the following features: 1) Generate valid responses for all API endpoints, 2) Support version-specific formatting differences, 3) Create helper functions for common response types (success, error, partial), 4) Include utilities for generating edge cases and boundary conditions, 5) Ensure type safety and proper interface adherence.\n\nUtilize the new client/test/jsonrpc package with its structured types and builders:\n- Use the JSONRPC type (renamed from Message) for structured JSON-RPC message representation\n- Leverage the RPCError type (renamed from Error) for standardized error handling\n- Implement builders.go functionality to create test messages with minimal boilerplate\n- Ensure all factories work with the new type system for better type safety\n- Create version-specific response generators that leverage the common structure\n\nProgress update:\n- Created client/test/jsonrpc/types.go with properly structured JSONRPC and RPCError types that better represent the JSON-RPC 2.0 specification\n- Implemented client/test/jsonrpc/builders.go with helper functions to create various types of JSON-RPC messages (requests, responses, errors)\n- Created specialized functions for building tool requests, error responses, and other common message patterns\n- Fixed the MockTransport implementation to work properly with the new types and prevent deadlocks\n- Updated response factories to properly handle ID replacement and protocol version differences\n- Implemented version-specific response formatters for resource requests across all three versions\n\nThe jsonrpc package now serves as a clean, type-safe foundation for all protocol tests, ensuring that JSON-RPC messages are properly structured according to the protocol specifications. This provides a solid basis for the next subtask focused on developing common assertion utilities for protocol testing.\n</info added on 2025-05-16T23:14:33.390Z>",
          "status": "done",
          "testStrategy": "Test each response factory against actual protocol specifications to verify compliance with each version's requirements. Verify that the new JSONRPC and RPCError types correctly represent all protocol variations."
        },
        {
          "id": 3,
          "title": "Develop Common Assertion Utilities for Protocol Testing",
          "description": "Implement helper functions for common assertions to validate request/response pairs, error handling, and correct protocol usage.",
          "dependencies": [
            1,
            2
          ],
          "details": "Create assertion utilities that: 1) Validate request formatting against protocol specifications, 2) Verify response handling including error cases, 3) Check protocol-specific headers and metadata, 4) Implement matchers for partial object comparison, 5) Support all protocol versions with version-specific validation rules, 6) Include timing and performance assertion helpers.\n\nIntegrate with the new jsonrpc package structure:\n- Build assertions that work directly with JSONRPC and RPCError types\n- Create specialized matchers for different parts of the JSON-RPC structure\n- Implement helpers that leverage the builders for creating expected values\n- Ensure assertions provide clear error messages that reference the structured types\n- Support validation across all protocol versions using the common type system",
          "status": "done",
          "testStrategy": "Create meta-tests that verify the assertion utilities themselves work correctly across different protocol versions and edge cases. Ensure the assertions work properly with the new JSONRPC and RPCError types."
        },
        {
          "id": 4,
          "title": "Build Parameterized Test Framework for Cross-Version Testing",
          "description": "Create a framework that runs tests across all protocol versions with support for matrix testing and reusable test fixtures.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Implement a parameterized test framework with: 1) Test runners that execute each test against all protocol versions, 2) Configuration matrix support for testing different client options, 3) Reusable fixtures for common test scenarios, 4) Parallel test execution capabilities, 5) Reporting tools that highlight version-specific failures, 6) Support for conditional tests that only run on specific versions.\n\nEnsure compatibility with the new architecture:\n- Design the framework to work seamlessly with the MockTransport implementation\n- Integrate with the jsonrpc package for type-safe test definitions\n- Create fixtures that leverage the builders for concise test setup\n- Support parameterized tests that vary both protocol version and message structure\n- Implement helpers that simplify working with the new separation of concerns",
          "status": "done",
          "testStrategy": "Verify the framework by implementing a small set of tests that run across all versions and confirm proper isolation and reporting. Test integration with the new jsonrpc package components."
        },
        {
          "id": 5,
          "title": "Refactor Existing Tests to Use New Infrastructure",
          "description": "Identify and eliminate duplicated test code by migrating existing tests to use the new testing infrastructure while maintaining backward compatibility.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Perform a systematic refactoring of existing tests: 1) Analyze current test coverage and identify duplication, 2) Create migration plan prioritizing high-value test cases, 3) Refactor tests to use MockTransport and assertion utilities, 4) Implement parameterized versions of tests that should run across all protocol versions, 5) Verify that refactored tests maintain the same coverage and validation, 6) Establish patterns for future test development.\n\nUpdate tests to use the new structure:\n- Convert existing tests to use the JSONRPC and RPCError types\n- Replace direct JSON construction with the builder patterns from jsonrpc package\n- Update assertions to use the new type-safe utilities\n- Refactor test setup to leverage the improved separation of concerns\n- Ensure backward compatibility while transitioning to the new architecture",
          "status": "done",
          "testStrategy": "Run both original and refactored tests in parallel to ensure equivalent coverage and behavior before finalizing migration. Verify that the tests correctly use the new jsonrpc package components."
        },
        {
          "id": 6,
          "title": "Document Testing Infrastructure with Examples and Best Practices",
          "description": "Create comprehensive documentation for the testing infrastructure including examples, guidelines for writing new tests, and best practices for test coverage.",
          "dependencies": [
            1,
            2,
            3,
            4,
            5
          ],
          "details": "Develop documentation that includes: 1) Overview of the testing architecture and components, 2) Step-by-step examples of writing tests for different scenarios, 3) Guidelines for version-specific testing considerations, 4) Best practices for achieving comprehensive coverage, 5) Troubleshooting guide for common testing issues, 6) API reference for all test utilities and mock implementations, 7) Contribution guidelines for extending the test infrastructure.\n\nDocument the new architecture:\n- Explain the separation of concerns between MockTransport and the jsonrpc package\n- Provide examples of using the JSONRPC and RPCError types\n- Show how to use the builders to create test messages concisely\n- Document the interaction patterns between the different components\n- Include migration guidelines for updating existing tests\n- Create a style guide for writing clean, maintainable tests with the new structure",
          "status": "done",
          "testStrategy": "Have team members review documentation and attempt to implement new tests following the guidelines to verify clarity and completeness. Ensure documentation accurately reflects the new architecture and component relationships."
        }
      ]
    },
    {
      "id": 27,
      "title": "Fix JSON-RPC Handling in Client Testing Infrastructure",
      "description": "Refactor and fix issues with JSON-RPC handling in the client testing infrastructure, focusing on proper integration of the new client/test/jsonrpc package, resolving mutex issues, and ensuring consistent error handling across all protocol versions.",
      "details": "This task involves several key components to improve the JSON-RPC handling in the client testing infrastructure:\n\n1. Integration of new JSON-RPC types:\n   - Ensure the new client/test/jsonrpc package with JSONRPC and RPCError types is properly integrated with all existing tests\n   - Update import statements across test files to use the new package\n   - Replace any custom JSON-RPC implementations with the standardized types\n\n2. Fix mutex issues in MockTransport:\n   - Identify and resolve potential deadlocks in the MockTransport implementation\n   - Review all mutex lock/unlock patterns to ensure proper synchronization\n   - Consider using sync.RWMutex where appropriate to improve concurrency\n   - Add documentation comments explaining the locking strategy\n\n3. Create focused JSON-RPC tests:\n   - Develop unit tests specifically for JSON-RPC marshaling/unmarshaling\n   - These tests should not depend on the full client implementation\n   - Test edge cases like malformed JSON, missing fields, and unexpected types\n   - Ensure tests cover all JSON-RPC message types used in the system\n\n4. Update client test files across protocol versions:\n   - Modify all test files in the draft, v20241105, and v20250326 protocol versions\n   - Ensure consistent use of the new JSONRPC and RPCError types\n   - Remove any duplicated JSON-RPC handling code\n   - Maintain backward compatibility with existing test cases\n\n5. Implement proper error handling:\n   - Create standardized error handling for JSON-RPC errors\n   - Ensure errors are properly propagated through the client stack\n   - Add appropriate context to errors for debugging\n   - Implement error type checking to allow specific error handling by clients\n\nThe implementation should maintain compatibility with the existing client core and transport implementations from Tasks 20 and 21, while building on the testing infrastructure from Task 26.",
      "testStrategy": "The testing strategy for this task will involve multiple levels of verification:\n\n1. Unit Tests:\n   - Create unit tests for the JSONRPC and RPCError types in isolation\n   - Test marshaling/unmarshaling with various valid and invalid inputs\n   - Verify error handling for malformed JSON and protocol errors\n   - Test edge cases like empty messages, maximum size messages, and special characters\n\n2. Integration Tests:\n   - Verify that the MockTransport correctly handles JSON-RPC messages\n   - Test concurrent access to the MockTransport to ensure mutex issues are resolved\n   - Confirm that all client tests across protocol versions pass with the new implementation\n   - Validate that error propagation works correctly through the client stack\n\n3. Regression Testing:\n   - Run all existing client tests to ensure they still pass with the new changes\n   - Compare test coverage before and after changes to ensure no reduction in coverage\n   - Verify that all protocol versions (draft, v20241105, v20250326) are properly tested\n\n4. Deadlock Detection:\n   - Implement tests with timeouts to detect potential deadlocks\n   - Use race detector tools (e.g., Go's -race flag) to identify race conditions\n   - Create stress tests that perform many concurrent operations to expose synchronization issues\n\n5. Documentation Verification:\n   - Ensure all new code is properly documented\n   - Verify that the JSON-RPC handling approach is consistently documented across all protocol versions\n   - Check that error handling patterns are clearly documented\n\nThe tests should be automated and included in the CI pipeline to ensure ongoing verification of the JSON-RPC handling functionality.",
      "status": "done",
      "dependencies": [
        20,
        21,
        26
      ],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 28,
      "title": "Fix Resource Content Handling in Server Implementation",
      "description": "Fix multiple issues with resource content handling in the server implementation, focusing on proper formatting, type handling, and parameter processing across various API versions.",
      "details": "This task requires fixing several issues in the server's resource content handling implementation:\n\n1. Fix the `formatResourceV20250326` function to properly handle content with mixed types:\n   - Review the current implementation in server/resource.go\n   - Ensure the function can correctly process content that contains different data types\n   - Implement proper type checking and conversion\n   - Handle edge cases like null values or unexpected types gracefully\n\n2. Fix the `formatResourceV20241105` function to correctly handle image and link content:\n   - Update the function to properly format image content (ensuring proper attributes like src, alt, width, height)\n   - Ensure link content is correctly formatted with href, text, and optional attributes\n   - Maintain backward compatibility with existing clients\n\n3. Modify the `ensureContentsArray` function to preserve empty arrays when requested:\n   - Update the function to check for explicit empty arrays vs. null/undefined values\n   - Add a parameter or logic to determine when empty arrays should be preserved\n   - Ensure consistent behavior across different API versions\n\n4. Update the `FormatResourceResponse` function to properly handle URI parameter:\n   - Fix how the URI parameter is processed and validated\n   - Ensure proper URI encoding/decoding where necessary\n   - Handle relative vs. absolute URIs correctly\n\n5. Fix potential issues with the `ProcessResourceRequest` function:\n   - Review error handling and edge cases\n   - Ensure proper validation of incoming requests\n   - Fix any race conditions or concurrency issues\n   - Improve logging for debugging purposes\n\n6. Update all relevant tests to match the specification requirements for resource content structure:\n   - Add test cases for mixed content types\n   - Add tests for empty arrays\n   - Add tests for various URI formats\n   - Ensure test coverage for all edge cases\n\nThe implementation should maintain backward compatibility while fixing these issues. Code should follow the project's style guidelines and include appropriate documentation.",
      "testStrategy": "Testing for this task should be comprehensive and cover all the fixed functionality:\n\n1. Unit Tests:\n   - Create unit tests for each fixed function (`formatResourceV20250326`, `formatResourceV20241105`, `ensureContentsArray`, `FormatResourceResponse`, `ProcessResourceRequest`)\n   - Test with various input types including edge cases (null values, empty arrays, mixed types)\n   - Test with malformed inputs to ensure proper error handling\n   - Verify that empty arrays are preserved when specified\n\n2. Integration Tests:\n   - Create integration tests that verify the entire resource handling flow\n   - Test API responses for different versions (20250326, 20241105)\n   - Verify correct content structure in responses\n   - Test with real-world examples of resources with mixed content types\n\n3. Regression Tests:\n   - Ensure existing functionality continues to work\n   - Verify that fixes don't break backward compatibility\n   - Test with existing client implementations if possible\n\n4. Performance Tests:\n   - Verify that the fixes don't introduce performance regressions\n   - Test with large resources to ensure efficient processing\n\n5. Documentation:\n   - Update API documentation to reflect the fixed behavior\n   - Document any changes to the expected request/response formats\n\n6. Manual Testing:\n   - Perform manual testing with real clients\n   - Verify correct rendering of resources with mixed content types\n   - Test URI handling with various URI formats\n\nAll tests should be automated where possible and included in the CI/CD pipeline. Test coverage should aim for at least 90% of the modified code.",
      "status": "done",
      "dependencies": [
        12
      ],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 29,
      "title": "Implement Full Sampling Functionality in Client Package",
      "description": "Develop comprehensive sampling functionality in the client package that supports all protocol versions (draft, v20241105, and v20250326) with different content types (text, image, audio) according to each version's specification.",
      "details": "This task requires implementing the complete sampling functionality in the client package, building upon the core client functionality from Task #20. The implementation should include:\n\n1. Define protocol-specific sampling structs for each version (draft, v20241105, and v20250326) that accurately represent the sampling specifications.\n2. Implement content type handlers for text, image, and audio for each protocol version, accounting for the differences in sampling requirements across versions.\n3. Create sampling request builders that construct properly formatted sampling requests according to each protocol version.\n4. Develop sampling response parsers that correctly interpret and validate responses from the server.\n5. Implement version negotiation logic to ensure the client uses the appropriate sampling format based on the server's supported protocol version.\n6. Add error handling for sampling-specific errors, including validation errors for malformed sampling specifications.\n7. Ensure backward compatibility with older protocol versions while supporting the latest features.\n8. Implement sampling configuration options that allow users to customize sampling behavior within the constraints of each protocol version.\n9. Document all sampling-related functions, structs, and methods with clear examples of usage for each protocol version and content type.\n10. Optimize sampling performance, especially for large content types like images and audio.\n\nThe implementation should follow the project's coding standards and patterns established in the core client implementation (Task #20).",
      "testStrategy": "The testing strategy for this task should ensure 100% protocol compliance and robust functionality:\n\n1. Unit Tests:\n   - Create unit tests for each sampling struct, validating that they correctly enforce the constraints defined in each protocol version.\n   - Test all content type handlers with valid and invalid inputs for each protocol version.\n   - Verify that sampling request builders generate correctly formatted requests for each protocol version.\n   - Test sampling response parsers with various response formats, including edge cases and error conditions.\n\n2. Integration Tests:\n   - Develop integration tests that verify the sampling functionality works end-to-end with mock servers implementing each protocol version.\n   - Test version negotiation by simulating servers with different supported protocol versions.\n   - Verify that the client correctly handles protocol version mismatches and gracefully degrades when necessary.\n\n3. Compatibility Tests:\n   - Create tests that verify backward compatibility with older protocol versions.\n   - Test forward compatibility where applicable, ensuring newer client versions work with older server implementations.\n\n4. Performance Tests:\n   - Benchmark sampling performance for different content types and sizes.\n   - Test memory usage during sampling operations, especially for large content.\n\n5. Compliance Tests:\n   - Create a comprehensive test suite that validates compliance with each protocol version's specification.\n   - Include tests for all required, optional, and conditional fields in the sampling specifications.\n   - Verify that the client correctly implements any protocol-specific behaviors or constraints.\n\n6. Error Handling Tests:\n   - Test all error conditions, including network errors, server errors, and validation errors.\n   - Verify that error messages are clear and actionable.\n\n7. Documentation Verification:\n   - Review and verify that all sampling-related documentation is accurate and includes examples for each protocol version and content type.\n\nAll tests should be automated and included in the CI/CD pipeline to ensure ongoing compliance as the codebase evolves.",
      "status": "done",
      "dependencies": [
        20
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Protocol-Specific Sampling Structs and Interfaces",
          "description": "Define and implement the core sampling structs and interfaces for each protocol version (draft, v20241105, and v20250326) that accurately represent the sampling specifications.",
          "dependencies": [],
          "details": "Create protocol-specific sampling structs that encapsulate the sampling parameters for each version. Define interfaces for sampling operations that abstract away version-specific details. Implement version detection and negotiation logic to select the appropriate sampling implementation based on server capabilities. Ensure proper type definitions and validation for sampling parameters across all protocol versions.\n<info added on 2025-05-17T00:13:43.193Z>\nCreate protocol-specific sampling structs that encapsulate the sampling parameters for each version. Define interfaces for sampling operations that abstract away version-specific details. Implement version detection and negotiation logic to select the appropriate sampling implementation based on server capabilities. Ensure proper type definitions and validation for sampling parameters across all protocol versions.\n\nImplementation includes:\n\n1. SamplingMessageContent struct with IsValidForVersion method that validates content types against the different protocol versions:\n   - draft and 2025-03-26 support text, image, and audio content types\n   - 2024-11-05 supports only text and image content types\n\n2. WithSamplingHandler method to set a handler for sampling requests\n3. enableSamplingCapability and disableSamplingCapability methods\n4. handleSamplingCreateMessage method that:\n   - Validates incoming message content types against the negotiated protocol version\n   - Invokes the registered handler if available\n   - Validates response content types against the protocol version\n   - Sends appropriate JSON-RPC responses\n\n5. Helper functions for creating sampling messages:\n   - CreateTextSamplingMessage\n   - CreateImageSamplingMessage\n   - CreateAudioSamplingMessage\n\nThe implementation is complete with proper content type validation against each protocol version's specifications, ensuring full compliance with all three protocol versions (draft, v20241105, v20250326).\n</info added on 2025-05-17T00:13:43.193Z>",
          "status": "done",
          "testStrategy": "Unit tests for struct validation, interface compliance, and version negotiation logic. Mock server responses to test version detection."
        },
        {
          "id": 2,
          "title": "Develop Content Type Handlers for Text, Image, and Audio",
          "description": "Implement specialized handlers for different content types (text, image, audio) that conform to the sampling requirements of each protocol version.",
          "dependencies": [
            1
          ],
          "details": "Create content-specific sampling implementations for text, image, and audio. Handle format differences between protocol versions for each content type. Implement content validation and preprocessing for sampling requests. Develop efficient serialization/deserialization for different content formats. Support protocol-specific content parameters and constraints.",
          "status": "done",
          "testStrategy": "Unit tests with sample content of each type. Integration tests verifying correct handling of different content formats across protocol versions."
        },
        {
          "id": 3,
          "title": "Build Sampling Request Construction and Response Parsing",
          "description": "Develop request builders and response parsers for sampling operations that properly format requests and interpret responses according to each protocol version.",
          "dependencies": [
            1,
            2
          ],
          "details": "Implement request builders that construct properly formatted sampling requests for each protocol version. Create response parsers that correctly interpret and validate sampling responses. Handle protocol-specific error responses and status codes. Implement retry logic for transient sampling errors. Support streaming responses for applicable protocol versions.\n<info added on 2025-05-17T00:36:21.873Z>\nImplement request builders that construct properly formatted sampling requests for each protocol version (draft, v20241105, v20250326) with proper parameter validation based on protocol requirements. Create specialized helper functions for common request types ensuring all parameters are formatted according to version specifications. \n\nDevelop response parsers that correctly interpret, validate and handle all potential response formats with version-specific validation for content types. Implement clear error messages for invalid response formats and support for parsing protocol-specific error codes.\n\nEnhance error handling with comprehensive error types for sampling-related failures, retry logic for transient errors (network issues, temporary server failures), detailed error context for debugging, and helper functions for common error handling patterns.\n\nImplement streaming response support by determining which protocol versions support streaming, creating handlers with proper backpressure mechanisms, adding support for cancellation of in-progress streaming requests, and developing utility functions for consuming streaming responses.\n\nThis implementation will build upon the content type handlers from subtask #29.2, focusing on the complete request/response cycle and robust error handling.\n</info added on 2025-05-17T00:36:21.873Z>",
          "status": "done",
          "testStrategy": "Unit tests for request construction and response parsing. Mock server interactions to test error handling and retry logic."
        },
        {
          "id": 4,
          "title": "Implement Sampling Configuration and Customization Options",
          "description": "Create a flexible configuration system that allows users to customize sampling behavior within the constraints of each protocol version.",
          "dependencies": [
            1,
            3
          ],
          "details": "Develop a configuration API for sampling parameters that enforces protocol-specific constraints. Implement default configurations for common sampling scenarios. Create helper methods for common sampling operations. Support runtime configuration changes. Implement configuration validation to prevent invalid sampling requests.",
          "status": "done",
          "testStrategy": "Unit tests for configuration validation and application. Integration tests verifying configuration effects on sampling behavior."
        },
        {
          "id": 5,
          "title": "Optimize Performance and Document Sampling Functionality",
          "description": "Optimize sampling performance for all content types and create comprehensive documentation with usage examples for each protocol version and content type.",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "Implement performance optimizations for large content types like images and audio. Add caching mechanisms for frequently used sampling configurations. Create comprehensive documentation with clear examples for each protocol version and content type. Develop integration tests that verify end-to-end sampling functionality. Ensure backward compatibility with older protocol versions while supporting the latest features.",
          "status": "done",
          "testStrategy": "Performance benchmarks for different content types and sizes. End-to-end tests verifying complete sampling workflows across all protocol versions."
        }
      ]
    },
    {
      "id": 30,
      "title": "Implement Full Sampling Handling in Server Package",
      "description": "Implement server-side sampling functionality across all protocol versions (draft, v20241105, v20250326), enabling the server to initiate sampling requests to clients with supported capabilities for different content types.",
      "details": "This task requires implementing the server-side of the sampling functionality across all protocol versions:\n\n1. Protocol Version Support:\n   - Implement sampling handlers for draft, v20241105, and v20250326 protocol versions\n   - Ensure backward compatibility between versions\n   - Add version detection and appropriate handler selection\n\n2. Content Type Handling:\n   - Implement text sampling according to each version's specification\n   - Implement image sampling according to each version's specification\n   - Implement audio sampling according to each version's specification\n   - Handle content-specific metadata and parameters\n\n3. Client Capability Detection:\n   - Add functionality to detect client sampling capabilities\n   - Store and track client capabilities in client sessions\n   - Only initiate sampling requests to clients with supported capabilities\n\n4. Request Flow Implementation:\n   - Implement sampling request initiation from server to client\n   - Handle sampling response processing from client\n   - Implement timeout handling for sampling requests\n   - Add proper request ID tracking and correlation\n\n5. Error Handling:\n   - Implement comprehensive error handling for network issues\n   - Handle protocol-specific error responses\n   - Add graceful degradation when sampling fails\n   - Implement retry mechanisms where appropriate\n\n6. Integration with Server Core:\n   - Integrate with the existing server core functionality from Task 10\n   - Ensure thread safety for concurrent sampling requests\n   - Implement proper resource management\n\n7. Configuration:\n   - Add configuration options for sampling behavior\n   - Implement rate limiting for sampling requests\n   - Add sampling priority mechanisms\n\nThis implementation should follow the project's coding standards and include comprehensive documentation for each component.",
      "testStrategy": "The testing strategy will verify the sampling functionality across all protocol versions and content types:\n\n1. Unit Tests:\n   - Test each sampling handler implementation in isolation\n   - Test version detection and handler selection logic\n   - Test client capability detection and tracking\n   - Test error handling and recovery mechanisms\n   - Mock client responses to test various scenarios\n\n2. Integration Tests:\n   - Test integration with server core components\n   - Test sampling request flow from initiation to completion\n   - Test concurrent sampling requests handling\n   - Test resource management under load\n\n3. Protocol Version Tests:\n   - Create specific test suites for each protocol version\n   - Test backward compatibility between versions\n   - Verify protocol-specific features and behaviors\n   - Test version negotiation edge cases\n\n4. Content Type Tests:\n   - Test text sampling with various text inputs and parameters\n   - Test image sampling with different image formats and sizes\n   - Test audio sampling with different audio formats and durations\n   - Test mixed content type scenarios\n\n5. Error Handling Tests:\n   - Test network failure scenarios\n   - Test timeout handling\n   - Test malformed response handling\n   - Test retry mechanisms\n\n6. Performance Tests:\n   - Measure sampling request latency\n   - Test system under high sampling request load\n   - Verify resource usage during sampling operations\n\n7. Compatibility Tests:\n   - Test with mock clients implementing different protocol versions\n   - Verify correct behavior with clients having limited capabilities\n\nAll tests should be automated and included in the CI/CD pipeline. Test coverage should aim for at least 90% of the new code.",
      "status": "done",
      "dependencies": [
        10
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Protocol Version Support for Sampling",
          "description": "Create handlers for sampling functionality across all protocol versions (draft, v20241105, v20250326) with proper version detection and backward compatibility.",
          "dependencies": [],
          "details": "Develop version-specific sampling handlers that implement the correct protocol specifications for each version. Implement a version detection mechanism that routes sampling requests to the appropriate handler. Ensure backward compatibility between versions by mapping newer features to equivalent functionality in older versions where possible. Create a unified interface for all handlers to simplify integration with the rest of the server package.\n<info added on 2025-05-17T00:14:00.545Z>\nDevelop version-specific sampling handlers that implement the correct protocol specifications for each version. Implement a version detection mechanism that routes sampling requests to the appropriate handler. Ensure backward compatibility between versions by mapping newer features to equivalent functionality in older versions where possible. Create a unified interface for all handlers to simplify integration with the rest of the server package.\n\nImplementation details:\n- Created core data structures for sampling functionality:\n  - SamplingMessageContent struct for handling different media types (text, image, audio)\n  - SamplingMessage struct to represent messages in sampling conversations\n  - SamplingModelHint and SamplingModelPreferences structs for model selection\n  - SamplingCreateMessageParams for request parameters\n  - SamplingResponse struct for responses\n\n- Implemented version-specific content type validation:\n  - draft and v20250326: support for text, image, and audio content types\n  - v20241105: support for text and image content types only\n\n- Added helper functions for creating sampling messages:\n  - CreateTextSamplingMessage\n  - CreateImageSamplingMessage\n  - CreateAudioSamplingMessage\n\n- Implemented RequestSampling method on the server to handle client sampling requests\n- Added clientInfo structure to track client capabilities including sampling support\n\nThe implementation ensures proper protocol compliance across all versions with appropriate content type handling based on protocol version specifications.\n</info added on 2025-05-17T00:14:00.545Z>",
          "status": "done",
          "testStrategy": "Create unit tests for each protocol version handler with mock requests and responses. Test version detection with various client headers. Verify backward compatibility by testing newer client requests against older protocol handlers."
        },
        {
          "id": 2,
          "title": "Implement Content Type Sampling Handlers",
          "description": "Develop handlers for text, image, and audio sampling according to each protocol version's specifications, including content-specific metadata and parameters.",
          "dependencies": [
            1
          ],
          "details": "Create specialized handlers for each content type (text, image, audio) that implement the sampling specifications for each protocol version. Implement proper handling of content-specific metadata and parameters required by each version. Design a flexible parameter validation system that can adapt to different protocol requirements. Ensure proper MIME type handling and content encoding/decoding for each content type.\n<info added on 2025-05-17T00:36:05.722Z>\nCreate specialized handlers for each content type (text, image, audio) that implement the sampling specifications for each protocol version. Implement proper handling of content-specific metadata and parameters required by each version. Design a flexible parameter validation system that can adapt to different protocol requirements. Ensure proper MIME type handling and content encoding/decoding for each content type.\n\nServer-side implementation plan:\n1. Create specialized content type handlers:\n   - TextSamplingContentHandler: Implement text-specific validation and processing\n   - ImageSamplingContentHandler: Add MIME type validation and image format handling\n   - AudioSamplingContentHandler: Support audio format validation and processing\n\n2. Enhance server-side sampling.go:\n   - Add content type validation functions that verify requests match protocol version capabilities\n   - Implement version-specific content type validation logic\n   - Create interfaces for content handlers to ensure consistent implementation\n   - Add helper methods for creating version-appropriate sampling requests\n\n3. Update RequestSampling method:\n   - Implement missing response handling functionality\n   - Add correlation mechanism for request/response pairing\n   - Implement wait mechanism with configurable timeout for receiving sampling responses\n   - Add proper error handling for content type validation failures\n\n4. Enhance ClientInfo structure:\n   - Track specific sampling capabilities by content type\n   - Store protocol version compatibility information\n   - Add validation methods to check client capabilities against request types\n\nAll implementations will follow the established pattern from the client-side code to maintain consistency across the codebase while ensuring protocol version compliance.\n</info added on 2025-05-17T00:36:05.722Z>",
          "status": "done",
          "testStrategy": "Develop comprehensive tests for each content type handler with various input formats and parameters. Test edge cases like empty content, oversized content, and malformed metadata."
        },
        {
          "id": 3,
          "title": "Implement Client Capability Detection and Management",
          "description": "Add functionality to detect, store, and track client sampling capabilities in client sessions, ensuring sampling requests are only sent to capable clients.",
          "dependencies": [
            1
          ],
          "details": "Develop a capability detection system that identifies client sampling support during connection establishment. Create a session storage mechanism to track client capabilities throughout the connection lifetime. Implement capability querying functions that other server components can use to check if a client supports specific sampling features. Design a capability negotiation protocol that allows graceful handling of partial capability support.",
          "status": "done",
          "testStrategy": "Test capability detection with various client headers and connection scenarios. Verify session storage persistence across multiple requests. Test capability querying with both supported and unsupported features."
        },
        {
          "id": 4,
          "title": "Implement Sampling Request Flow and Processing",
          "description": "Create the complete request flow for server-initiated sampling, including request initiation, response processing, timeout handling, and request tracking.",
          "dependencies": [
            2,
            3
          ],
          "details": "Implement the server-side initiation of sampling requests to clients. Develop response handlers that process and validate client sampling responses. Create a timeout management system for sampling requests with appropriate fallback behavior. Implement request ID generation, tracking, and correlation to match responses with requests. Design an asynchronous processing pipeline that can handle concurrent sampling requests efficiently.",
          "status": "done",
          "testStrategy": "Test the complete request flow with mock clients. Verify timeout handling by simulating delayed responses. Test request tracking with multiple concurrent requests. Validate response processing with both valid and invalid client responses."
        },
        {
          "id": 5,
          "title": "Integrate Sampling with Server Core and Add Configuration",
          "description": "Integrate sampling functionality with the existing server core, implement error handling, and add configurable sampling behavior with rate limiting and priority mechanisms.",
          "dependencies": [
            4
          ],
          "details": "Integrate the sampling implementation with the server core functionality from Task 10. Implement comprehensive error handling for network issues, protocol-specific errors, and unexpected client behavior. Add graceful degradation and retry mechanisms for failed sampling requests. Develop configuration options for sampling behavior, including rate limiting, priority mechanisms, and resource allocation. Ensure thread safety for concurrent sampling operations and implement proper resource management to prevent memory leaks or resource exhaustion.",
          "status": "done",
          "testStrategy": "Test integration with server core using integration tests. Verify error handling by simulating various failure scenarios. Test configuration options to ensure they properly affect sampling behavior. Perform load testing to verify thread safety and resource management under high concurrency."
        }
      ]
    },
    {
      "id": 31,
      "title": "Task #31: Migrate Test Files to Dedicated Test Directories",
      "description": "Reorganize the project's test structure by moving test files from main package directories to dedicated test directories, updating package declarations, imports, and test code to work with the new structure.",
      "details": "This task involves a comprehensive restructuring of the test organization:\n\n1. Create dedicated test directories:\n   - Create server/test/ directory for server tests\n   - Create client/test/ directory for client tests\n\n2. Move test files:\n   - Identify all *_test.go files in server/ and client/ directories\n   - Move server test files to server/test/\n   - Move client test files to client/test/\n\n3. Update package declarations:\n   - Change package declarations in server tests from 'package server' to 'package test'\n   - Change package declarations in client tests from 'package client' to 'package test'\n\n4. Fix imports and references:\n   - Add proper imports for server and client packages in respective test files\n   - Update any internal references that relied on being in the same package\n   - Fix type assertions and method calls to work with the new package structure\n   - Update access to unexported fields/methods (may require adding exported accessor methods in the main packages)\n\n5. Create test helpers:\n   - Implement helper functions in server/test/helpers.go and client/test/helpers.go\n   - Create test fixtures and utilities to facilitate testing through public APIs\n   - Ensure helpers provide clean interfaces for common test operations\n\n6. Update any build scripts or CI configurations that might reference the old test locations\n\nThis restructuring will improve code organization by separating tests from implementation code while maintaining test coverage. The task should be approached methodically, moving and updating one test file at a time to minimize disruption.",
      "testStrategy": "The completion of this task can be verified through the following steps:\n\n1. Directory structure verification:\n   - Confirm server/test/ and client/test/ directories exist\n   - Verify no test files remain in the main server/ and client/ directories\n   - Check that all test files are properly placed in their respective test directories\n\n2. Code compilation check:\n   - Run `go build ./...` to verify there are no compilation errors after the migration\n   - Ensure all package declarations and imports are correctly updated\n\n3. Test execution:\n   - Run `go test ./server/test/...` and `go test ./client/test/...` to verify all tests pass\n   - Compare test coverage reports before and after migration to ensure no tests were lost\n   - Run `go test -race ./...` to check for any race conditions that might have been introduced\n\n4. Code review:\n   - Review package declarations in all test files to confirm they use 'package test'\n   - Verify proper imports for server and client packages are present\n   - Check that test helpers are implemented and used appropriately\n   - Ensure tests are using public APIs rather than relying on internal implementation details\n\n5. CI/CD verification:\n   - Confirm that continuous integration builds complete successfully\n   - Verify that any test-related scripts or workflows have been updated to reference the new test locations\n\nDocument any issues encountered during the migration and how they were resolved for future reference.",
      "status": "done",
      "dependencies": [
        20,
        10
      ],
      "priority": "high",
      "subtasks": []
    }
  ]
}