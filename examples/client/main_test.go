package main

import (
	"context" // Needed for dummy handlers
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"os" // Needed for dummy filesystem handler
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/localrivet/gomcp"
	// "github.com/google/uuid" // No longer needed here, ID generated by SendRequest
)

// --- Test Setup ---

// createTestConnections creates a pair of connected in-memory pipes
// suitable for testing client-server interactions without real network I/O.
func createTestConnections() (*gomcp.Connection, *gomcp.Connection) {
	serverReader, clientWriter := io.Pipe()
	clientReader, serverWriter := io.Pipe()
	// Use the standard NewConnection. Closing the pipes handles cleanup.
	serverConn := gomcp.NewConnection(serverReader, serverWriter)
	clientConn := gomcp.NewConnection(clientReader, clientWriter)
	return serverConn, clientConn
}

// Helper to receive and decode a JSON-RPC response within a timeout
func receiveResponse(t *testing.T, conn *gomcp.Connection, expectedID interface{}, timeout time.Duration) (*gomcp.JSONRPCResponse, error) {
	t.Helper()
	rawJSONChan := make(chan []byte)
	errChan := make(chan error, 1)

	go func() {
		raw, err := conn.ReceiveRawMessage()
		if err != nil {
			errChan <- err
			return
		}
		rawJSONChan <- raw
	}()

	select {
	case rawJSON := <-rawJSONChan:
		// log.Printf("Client simulator received raw: %s", string(rawJSON)) // Uncomment for debugging
		var resp gomcp.JSONRPCResponse
		if err := json.Unmarshal(rawJSON, &resp); err != nil {
			// Try unmarshalling as a batch response (array) in case server sends one unexpectedly
			var batchResp []gomcp.JSONRPCResponse
			if errBatch := json.Unmarshal(rawJSON, &batchResp); errBatch == nil && len(batchResp) > 0 {
				// For simplicity in this test, just check the first response in the batch
				resp = batchResp[0]
			} else {
				return nil, fmt.Errorf("failed to unmarshal response JSON (not single or batch): %w. Raw: %s", err, string(rawJSON))
			}
		}

		// Check ID matching (handle potential type differences like int vs float64 from JSON)
		if expectedID != nil && fmt.Sprintf("%v", resp.ID) != fmt.Sprintf("%v", expectedID) {
			return nil, fmt.Errorf("response ID mismatch. Expected: %v, Got: %v", expectedID, resp.ID)
		}
		// Check for protocol-level error BEFORE checking for null result
		if resp.Error != nil {
			return nil, fmt.Errorf("received MCP Error: [%d] %s", resp.Error.Code, resp.Error.Message)
		}
		// Allow null result for Ping, otherwise check if result is present
		if resp.Result == nil && resp.Error == nil {
			// We need method context to definitively say null result is bad,
			// but for this test's flow, only Ping should have a null result.
			// We'll check specific results later.
		}
		return &resp, nil
	case err := <-errChan:
		// Check for expected pipe closure errors which might be okay depending on test stage
		if errors.Is(err, io.ErrClosedPipe) || errors.Is(err, io.EOF) || strings.Contains(err.Error(), "closed") {
			return nil, fmt.Errorf("connection closed while waiting for response (Expected ID: %v): %w", expectedID, err)
		}
		return nil, fmt.Errorf("error receiving response: %w", err)
	case <-time.After(timeout):
		return nil, fmt.Errorf("timeout waiting for response (Expected ID: %v)", expectedID)
	}
}

// Helper to receive and decode a JSON-RPC message (Request or Notification) within a timeout
func receiveRequestOrNotification(t *testing.T, conn *gomcp.Connection, timeout time.Duration) (map[string]interface{}, error) {
	t.Helper()
	rawJSONChan := make(chan []byte)
	errChan := make(chan error, 1)

	go func() {
		raw, err := conn.ReceiveRawMessage()
		if err != nil {
			errChan <- err
			return
		}
		rawJSONChan <- raw
	}()

	select {
	case rawJSON := <-rawJSONChan:
		// log.Printf("Server simulator received raw: %s", string(rawJSON)) // Uncomment for debugging
		var baseMsg map[string]interface{}
		if err := json.Unmarshal(rawJSON, &baseMsg); err != nil {
			return nil, fmt.Errorf("failed to unmarshal raw message: %w. Raw: %s", err, string(rawJSON))
		}
		// Basic JSON-RPC validation
		if _, ok := baseMsg["jsonrpc"].(string); !ok || baseMsg["jsonrpc"] != "2.0" {
			return nil, fmt.Errorf("invalid or missing jsonrpc version: %v", baseMsg["jsonrpc"])
		}
		if _, ok := baseMsg["method"].(string); !ok {
			// Could be a response, but this helper expects requests/notifications
			return nil, fmt.Errorf("message is not a request or notification (missing method)")
		}
		return baseMsg, nil
	case err := <-errChan:
		// Check for expected pipe closure errors
		if errors.Is(err, io.ErrClosedPipe) || errors.Is(err, io.EOF) || strings.Contains(err.Error(), "closed") {
			return nil, fmt.Errorf("connection closed while waiting for message: %w", err)
		}
		return nil, fmt.Errorf("error receiving message: %w", err)
	case <-time.After(timeout):
		return nil, fmt.Errorf("timeout waiting for message")
	}
}

// --- Dummy Handlers and Data for Server Simulation ---
// These need to exist in the test file because main.go is in package main
// and cannot be directly imported/used by another main package test file.

var testEchoTool = gomcp.Tool{
	Name:        "echo",
	Description: "Test Echo",
	InputSchema: gomcp.ToolInputSchema{Type: "object", Properties: map[string]gomcp.PropertyDetail{"message": {Type: "string"}}, Required: []string{"message"}},
}
var testCalculatorTool = gomcp.Tool{
	Name:        "calculator",
	Description: "Test Calc",
	InputSchema: gomcp.ToolInputSchema{
		Type: "object",
		Properties: map[string]gomcp.PropertyDetail{
			"operand1":  {Type: "number"},
			"operand2":  {Type: "number"},
			"operation": {Type: "string", Enum: []interface{}{"add", "subtract", "multiply", "divide"}},
		},
		Required: []string{"operand1", "operand2", "operation"},
	},
}
var testFileSystemTool = gomcp.Tool{
	Name:        "filesystem",
	Description: "Test FS",
	InputSchema: gomcp.ToolInputSchema{
		Type: "object",
		Properties: map[string]gomcp.PropertyDetail{
			"operation": {Type: "string", Enum: []interface{}{"list_files", "read_file", "write_file"}},
			"path":      {Type: "string"},
			"content":   {Type: "string"},
		},
		Required: []string{"operation", "path"},
	},
}

// Simplified dummy calculator handler for testing
func testCalculatorHandler(ctx context.Context, pt *gomcp.ProgressToken, args map[string]interface{}) ([]gomcp.Content, bool) {
	op1, ok1 := args["operand1"].(float64)
	op2, ok2 := args["operand2"].(float64)
	opStr, ok3 := args["operation"].(string)
	if !ok1 || !ok2 || !ok3 {
		return []gomcp.Content{gomcp.TextContent{Type: "text", Text: "Missing required arguments"}}, true
	}
	var result float64
	isErrTrue := true // Local variable for error flag pointer
	switch opStr {
	case "add":
		result = op1 + op2
	case "subtract":
		result = op1 - op2
	case "multiply":
		result = op1 * op2
	case "divide":
		if op2 == 0 {
			return []gomcp.Content{gomcp.TextContent{Type: "text", Text: "Division by zero"}}, isErrTrue
		}
		result = op1 / op2
	default:
		return []gomcp.Content{gomcp.TextContent{Type: "text", Text: "Invalid operation"}}, isErrTrue
	}
	return []gomcp.Content{gomcp.TextContent{Type: "text", Text: fmt.Sprintf("%f", result)}}, false
}

// Simplified dummy filesystem handler for testing basic calls
func testFilesystemHandler(ctx context.Context, pt *gomcp.ProgressToken, args map[string]interface{}) ([]gomcp.Content, bool) {
	op, _ := args["operation"].(string)
	path, _ := args["path"].(string)
	isErrTrue := true

	// Simulate basic responses based on the client test expectations
	switch op {
	case "list_files":
		if path == "." {
			return []gomcp.Content{gomcp.TextContent{Type: "text", Text: `{"files":[]}`}}, false
		} else if path == "test_dir" {
			fileInfo := map[string]interface{}{"name": "my_file.txt", "is_dir": false, "size": 46, "mod_time": "2024-01-01T12:00:00Z"}
			resultMap := map[string]interface{}{"files": []interface{}{fileInfo}}
			resultBytes, _ := json.Marshal(resultMap)
			return []gomcp.Content{gomcp.TextContent{Type: "text", Text: string(resultBytes)}}, false
		}
	case "write_file":
		if path == "../outside_sandbox.txt" {
			return []gomcp.Content{gomcp.TextContent{Type: "text", Text: "path '../outside_sandbox.txt' attempts to escape the sandbox"}}, isErrTrue
		}
		resultMap := map[string]interface{}{"status": "success", "message": "Simulated write success"}
		resultBytes, _ := json.Marshal(resultMap)
		return []gomcp.Content{gomcp.TextContent{Type: "text", Text: string(resultBytes)}}, false
	case "read_file":
		if path == "test_dir/my_file.txt" {
			return []gomcp.Content{gomcp.TextContent{Type: "text", Text: "This is the content of the test file.\nIt has multiple lines."}}, false
		} else if path == "non_existent_file.txt" {
			return []gomcp.Content{gomcp.TextContent{Type: "text", Text: "File not found at path 'non_existent_file.txt'"}}, isErrTrue
		}
	}
	return []gomcp.Content{gomcp.TextContent{Type: "text", Text: fmt.Sprintf("Unhandled filesystem operation/path: %s %s", op, path)}}, isErrTrue
}

// --- Test Function ---

func TestExampleClientLogic(t *testing.T) {
	originalOutput := log.Writer()
	// log.SetOutput(os.Stderr) // Enable for debugging test
	log.SetOutput(io.Discard) // Discard logs during test run
	defer log.SetOutput(originalOutput)

	serverConn, clientConn := createTestConnections()
	defer serverConn.Close()
	// clientConn is closed by the client logic's defer client.Close()

	testServerName := "TestClientLogicServer"
	testClientName := "TestClientLogicClient-Refactored"

	// Clean up sandbox directory potentially created by the *real* filesystem handler if run locally
	// Note: The test itself uses an in-memory simulation, but cleanup is good practice.
	sandboxDir := "./fs_sandbox" // Match the constant in the actual filesystem.go
	_ = os.RemoveAll(sandboxDir)
	defer func() {
		log.SetOutput(originalOutput)
		log.Printf("Cleaning up potential sandbox directory: %s", sandboxDir)
		_ = os.RemoveAll(sandboxDir)
	}()

	var serverWg sync.WaitGroup
	var clientWg sync.WaitGroup
	var clientErr error // Declare clientErr in the outer scope
	var serverErr error // Declare serverErr in the outer scope

	// --- Server Simulator Goroutine ---
	serverWg.Add(1)
	go func() {
		defer serverWg.Done()
		defer serverConn.Close()
		log.Println("Server simulator: Started.")

		// Helper to send a JSON-RPC response
		sendResponse := func(id interface{}, result interface{}) bool {
			err := serverConn.SendResponse(id, result)
			if err != nil {
				log.Printf("ERROR (Server simulator): failed to send response (ID: %v): %v", id, err)
				return false
			}
			log.Printf("Server simulator: Sent Response (ID: %v)", id)
			return true
		}

		// 1. Handle InitializeRequest
		msg, err := receiveRequestOrNotification(t, serverConn, 5*time.Second)
		if err != nil {
			serverErr = fmt.Errorf("server simulator: Error receiving init request: %w", err)
			return
		}
		reqID, idOk := msg["id"]
		method, _ := msg["method"].(string)
		if !idOk || method != gomcp.MethodInitialize {
			serverErr = fmt.Errorf("server simulator: Expected InitializeRequest, got method '%s', id present: %v", method, idOk)
			return
		}
		log.Printf("Server simulator: Received InitializeRequest (ID: %v)", reqID)

		// Send InitializeResponse
		initResult := gomcp.InitializeResult{
			ProtocolVersion: gomcp.CurrentProtocolVersion,
			ServerInfo:      gomcp.Implementation{Name: testServerName, Version: "0.1.0"},
			Capabilities: gomcp.ServerCapabilities{ // Advertise capabilities matching dummy tools
				Tools: &struct {
					ListChanged bool `json:"listChanged,omitempty"`
				}{ListChanged: false}, // Keep it simple for this test
			},
		}
		if !sendResponse(reqID, initResult) {
			serverErr = fmt.Errorf("server simulator: failed to send initialize resp")
			return
		}

		// 2. Handle Initialized Notification
		msg, err = receiveRequestOrNotification(t, serverConn, 1*time.Second) // Short timeout ok
		if err != nil {
			serverErr = fmt.Errorf("server simulator: Error receiving initialized notification: %w", err)
			return
		}
		method, _ = msg["method"].(string)
		_, idExists := msg["id"]
		if idExists || method != gomcp.MethodInitialized {
			serverErr = fmt.Errorf("server simulator: Expected Initialized notification, got: %+v", msg)
			return
		}
		log.Println("Server simulator: Received Initialized notification.")

		// 3. Handle ListToolsRequest
		msg, err = receiveRequestOrNotification(t, serverConn, 5*time.Second)
		if err != nil {
			serverErr = fmt.Errorf("server simulator: Error receiving list tools req: %w", err)
			return
		}
		reqID, idOk = msg["id"]
		method, _ = msg["method"].(string)
		if !idOk || method != gomcp.MethodListTools {
			serverErr = fmt.Errorf("server simulator: Expected ListToolsRequest")
			return
		}
		log.Printf("Server simulator: Received ListToolsRequest (ID: %v)", reqID)

		tools := []gomcp.Tool{testEchoTool, testCalculatorTool, testFileSystemTool}
		listToolsResp := gomcp.ListToolsResult{Tools: tools}
		if !sendResponse(reqID, listToolsResp) {
			serverErr = fmt.Errorf("server simulator: failed to send list tools resp")
			return
		}

		// 4. Handle CallToolRequest (echo)
		msg, err = receiveRequestOrNotification(t, serverConn, 5*time.Second)
		if err != nil {
			serverErr = fmt.Errorf("server simulator: Error receiving echo req: %w", err)
			return
		}
		reqID, idOk = msg["id"]
		method, _ = msg["method"].(string)
		paramsRaw, paramsOk := msg["params"]
		if !idOk || method != gomcp.MethodCallTool || !paramsOk {
			serverErr = fmt.Errorf("server simulator: Expected CallToolRequest(echo)")
			return
		}
		log.Printf("Server simulator: Received CallToolRequest(echo) (ID: %v)", reqID)
		var ctReqEcho gomcp.CallToolParams
		if err := gomcp.UnmarshalPayload(paramsRaw, &ctReqEcho); err != nil || ctReqEcho.Name != "echo" {
			serverErr = fmt.Errorf("server simulator: bad echo req: %w", err)
			return
		}
		echoResp := gomcp.CallToolResult{Content: []gomcp.Content{gomcp.TextContent{Type: "text", Text: ctReqEcho.Arguments["message"].(string)}}}
		if !sendResponse(reqID, echoResp) {
			serverErr = fmt.Errorf("server simulator: failed to send echo resp")
			return
		}

		// 5. Handle CallToolRequest (calculator add)
		msg, err = receiveRequestOrNotification(t, serverConn, 5*time.Second)
		if err != nil {
			serverErr = fmt.Errorf("server simulator: Error receiving calc(add) req: %w", err)
			return
		}
		reqID, idOk = msg["id"]
		method, _ = msg["method"].(string)
		paramsRaw, paramsOk = msg["params"]
		if !idOk || method != gomcp.MethodCallTool || !paramsOk {
			serverErr = fmt.Errorf("server simulator: Expected CallToolRequest(calc add)")
			return
		}
		log.Printf("Server simulator: Received CallToolRequest(calc add) (ID: %v)", reqID)
		var ctReqCalc1 gomcp.CallToolParams
		if err := gomcp.UnmarshalPayload(paramsRaw, &ctReqCalc1); err != nil || ctReqCalc1.Name != "calculator" {
			serverErr = fmt.Errorf("server simulator: bad calc(add) req: %w", err)
			return
		}
		calcResp1, isErr1 := testCalculatorHandler(context.Background(), nil, ctReqCalc1.Arguments) // Use dummy handler
		calcResult1 := gomcp.CallToolResult{Content: calcResp1, IsError: BoolPtr(isErr1)}           // Use local BoolPtr
		if !sendResponse(reqID, calcResult1) {
			serverErr = fmt.Errorf("server simulator: failed to send calc add resp")
			return
		}

		// 6. Handle CallToolRequest (calculator divide by zero)
		msg, err = receiveRequestOrNotification(t, serverConn, 5*time.Second)
		if err != nil {
			serverErr = fmt.Errorf("server simulator: Error receiving calc(div0) req: %w", err)
			return
		}
		reqID, idOk = msg["id"]
		method, _ = msg["method"].(string)
		paramsRaw, paramsOk = msg["params"]
		if !idOk || method != gomcp.MethodCallTool || !paramsOk {
			serverErr = fmt.Errorf("server simulator: Expected CallToolRequest(calc div0)")
			return
		}
		log.Printf("Server simulator: Received CallToolRequest(calc div0) (ID: %v)", reqID)
		var ctReqCalc2 gomcp.CallToolParams
		if err := gomcp.UnmarshalPayload(paramsRaw, &ctReqCalc2); err != nil || ctReqCalc2.Name != "calculator" {
			serverErr = fmt.Errorf("server simulator: bad calc(div0) req: %w", err)
			return
		}
		calcResp2, isErr2 := testCalculatorHandler(context.Background(), nil, ctReqCalc2.Arguments) // Use dummy handler
		calcResult2 := gomcp.CallToolResult{Content: calcResp2, IsError: BoolPtr(isErr2)}           // Use local BoolPtr
		if !sendResponse(reqID, calcResult2) {
			serverErr = fmt.Errorf("server simulator: failed to send calc div0 resp")
			return
		}

		// 7. Handle CallToolRequest (calculator missing arg)
		msg, err = receiveRequestOrNotification(t, serverConn, 5*time.Second)
		if err != nil {
			serverErr = fmt.Errorf("server simulator: Error receiving calc(miss) req: %w", err)
			return
		}
		reqID, idOk = msg["id"]
		method, _ = msg["method"].(string)
		paramsRaw, paramsOk = msg["params"]
		if !idOk || method != gomcp.MethodCallTool || !paramsOk {
			serverErr = fmt.Errorf("server simulator: Expected CallToolRequest(calc miss)")
			return
		}
		log.Printf("Server simulator: Received CallToolRequest(calc miss) (ID: %v)", reqID)
		var ctReqCalc3 gomcp.CallToolParams
		if err := gomcp.UnmarshalPayload(paramsRaw, &ctReqCalc3); err != nil || ctReqCalc3.Name != "calculator" {
			serverErr = fmt.Errorf("server simulator: bad calc(miss) req: %w", err)
			return
		}
		calcResp3, isErr3 := testCalculatorHandler(context.Background(), nil, ctReqCalc3.Arguments) // Use dummy handler
		calcResult3 := gomcp.CallToolResult{Content: calcResp3, IsError: BoolPtr(isErr3)}           // Use local BoolPtr
		if !sendResponse(reqID, calcResult3) {
			serverErr = fmt.Errorf("server simulator: failed to send calc miss resp")
			return
		}

		// 8. Handle CallToolRequest (filesystem list .)
		msg, err = receiveRequestOrNotification(t, serverConn, 5*time.Second)
		if err != nil {
			serverErr = fmt.Errorf("server simulator: Error receiving fs(list .) req: %w", err)
			return
		}
		reqID, idOk = msg["id"]
		method, _ = msg["method"].(string)
		paramsRaw, paramsOk = msg["params"]
		if !idOk || method != gomcp.MethodCallTool || !paramsOk {
			serverErr = fmt.Errorf("server simulator: Expected CallToolRequest(fs list .)")
			return
		}
		log.Printf("Server simulator: Received CallToolRequest(fs list .) (ID: %v)", reqID)
		var ctReqFs1 gomcp.CallToolParams
		if err := gomcp.UnmarshalPayload(paramsRaw, &ctReqFs1); err != nil || ctReqFs1.Name != "filesystem" {
			serverErr = fmt.Errorf("server simulator: bad fs(list .) req: %w", err)
			return
		}
		fsResp1, fsIsErr1 := testFilesystemHandler(context.Background(), nil, ctReqFs1.Arguments)
		fsResult1 := gomcp.CallToolResult{Content: fsResp1, IsError: BoolPtr(fsIsErr1)} // Use local BoolPtr
		if !sendResponse(reqID, fsResult1) {
			serverErr = fmt.Errorf("server simulator: failed to send fs list . resp")
			return
		}

		// 9. Handle CallToolRequest (filesystem write)
		msg, err = receiveRequestOrNotification(t, serverConn, 5*time.Second)
		if err != nil {
			serverErr = fmt.Errorf("server simulator: Error receiving fs(write) req: %w", err)
			return
		}
		reqID, idOk = msg["id"]
		method, _ = msg["method"].(string)
		paramsRaw, paramsOk = msg["params"]
		if !idOk || method != gomcp.MethodCallTool || !paramsOk {
			serverErr = fmt.Errorf("server simulator: Expected CallToolRequest(fs write)")
			return
		}
		log.Printf("Server simulator: Received CallToolRequest(fs write) (ID: %v)", reqID)
		var ctReqFs2 gomcp.CallToolParams
		if err := gomcp.UnmarshalPayload(paramsRaw, &ctReqFs2); err != nil || ctReqFs2.Name != "filesystem" {
			serverErr = fmt.Errorf("server simulator: bad fs(write) req: %w", err)
			return
		}
		fsResp2, fsIsErr2 := testFilesystemHandler(context.Background(), nil, ctReqFs2.Arguments)
		fsResult2 := gomcp.CallToolResult{Content: fsResp2, IsError: BoolPtr(fsIsErr2)} // Use local BoolPtr
		if !sendResponse(reqID, fsResult2) {
			serverErr = fmt.Errorf("server simulator: failed to send fs write resp")
			return
		}

		// 10. Handle CallToolRequest (filesystem read)
		msg, err = receiveRequestOrNotification(t, serverConn, 5*time.Second)
		if err != nil {
			serverErr = fmt.Errorf("server simulator: Error receiving fs(read) req: %w", err)
			return
		}
		reqID, idOk = msg["id"]
		method, _ = msg["method"].(string)
		paramsRaw, paramsOk = msg["params"]
		if !idOk || method != gomcp.MethodCallTool || !paramsOk {
			serverErr = fmt.Errorf("server simulator: Expected CallToolRequest(fs read)")
			return
		}
		log.Printf("Server simulator: Received CallToolRequest(fs read) (ID: %v)", reqID)
		var ctReqFs3 gomcp.CallToolParams
		if err := gomcp.UnmarshalPayload(paramsRaw, &ctReqFs3); err != nil || ctReqFs3.Name != "filesystem" {
			serverErr = fmt.Errorf("server simulator: bad fs(read) req: %w", err)
			return
		}
		fsResp3, fsIsErr3 := testFilesystemHandler(context.Background(), nil, ctReqFs3.Arguments)
		fsResult3 := gomcp.CallToolResult{Content: fsResp3, IsError: BoolPtr(fsIsErr3)} // Use local BoolPtr
		if !sendResponse(reqID, fsResult3) {
			serverErr = fmt.Errorf("server simulator: failed to send fs read resp")
			return
		}

		// 11. Handle CallToolRequest (filesystem list dir)
		msg, err = receiveRequestOrNotification(t, serverConn, 5*time.Second)
		if err != nil {
			serverErr = fmt.Errorf("server simulator: Error receiving fs(list dir) req: %w", err)
			return
		}
		reqID, idOk = msg["id"]
		method, _ = msg["method"].(string)
		paramsRaw, paramsOk = msg["params"]
		if !idOk || method != gomcp.MethodCallTool || !paramsOk {
			serverErr = fmt.Errorf("server simulator: Expected CallToolRequest(fs list dir)")
			return
		}
		log.Printf("Server simulator: Received CallToolRequest(fs list dir) (ID: %v)", reqID)
		var ctReqFs4 gomcp.CallToolParams
		if err := gomcp.UnmarshalPayload(paramsRaw, &ctReqFs4); err != nil || ctReqFs4.Name != "filesystem" {
			serverErr = fmt.Errorf("server simulator: bad fs(list dir) req: %w", err)
			return
		}
		fsResp4, fsIsErr4 := testFilesystemHandler(context.Background(), nil, ctReqFs4.Arguments)
		fsResult4 := gomcp.CallToolResult{Content: fsResp4, IsError: BoolPtr(fsIsErr4)} // Use local BoolPtr
		if !sendResponse(reqID, fsResult4) {
			serverErr = fmt.Errorf("server simulator: failed to send fs list dir resp")
			return
		}

		// 12. Handle CallToolRequest (filesystem read non-existent)
		msg, err = receiveRequestOrNotification(t, serverConn, 5*time.Second)
		if err != nil {
			serverErr = fmt.Errorf("server simulator: Error receiving fs(read nf) req: %w", err)
			return
		}
		reqID, idOk = msg["id"]
		method, _ = msg["method"].(string)
		paramsRaw, paramsOk = msg["params"]
		if !idOk || method != gomcp.MethodCallTool || !paramsOk {
			serverErr = fmt.Errorf("server simulator: Expected CallToolRequest(fs read nf)")
			return
		}
		log.Printf("Server simulator: Received CallToolRequest(fs read nf) (ID: %v)", reqID)
		var ctReqFs5 gomcp.CallToolParams
		if err := gomcp.UnmarshalPayload(paramsRaw, &ctReqFs5); err != nil || ctReqFs5.Name != "filesystem" {
			serverErr = fmt.Errorf("server simulator: bad fs(read nf) req: %w", err)
			return
		}
		fsResp5, fsIsErr5 := testFilesystemHandler(context.Background(), nil, ctReqFs5.Arguments)
		fsResult5 := gomcp.CallToolResult{Content: fsResp5, IsError: BoolPtr(fsIsErr5)} // Use local BoolPtr
		if !sendResponse(reqID, fsResult5) {
			serverErr = fmt.Errorf("server simulator: failed to send fs read nf resp")
			return
		}

		// 13. Handle CallToolRequest (filesystem write outside)
		msg, err = receiveRequestOrNotification(t, serverConn, 5*time.Second)
		if err != nil {
			serverErr = fmt.Errorf("server simulator: Error receiving fs(write outside) req: %w", err)
			return
		}
		reqID, idOk = msg["id"]
		method, _ = msg["method"].(string)
		paramsRaw, paramsOk = msg["params"]
		if !idOk || method != gomcp.MethodCallTool || !paramsOk {
			serverErr = fmt.Errorf("server simulator: Expected CallToolRequest(fs write outside)")
			return
		}
		log.Printf("Server simulator: Received CallToolRequest(fs write outside) (ID: %v)", reqID)
		var ctReqFs6 gomcp.CallToolParams
		if err := gomcp.UnmarshalPayload(paramsRaw, &ctReqFs6); err != nil || ctReqFs6.Name != "filesystem" {
			serverErr = fmt.Errorf("server simulator: bad fs(write outside) req: %w", err)
			return
		}
		fsResp6, fsIsErr6 := testFilesystemHandler(context.Background(), nil, ctReqFs6.Arguments)
		fsResult6 := gomcp.CallToolResult{Content: fsResp6, IsError: BoolPtr(fsIsErr6)} // Use local BoolPtr
		if !sendResponse(reqID, fsResult6) {
			serverErr = fmt.Errorf("server simulator: failed to send fs write outside resp")
			return
		}

		// 14. Handle Ping request
		msg, err = receiveRequestOrNotification(t, serverConn, 5*time.Second)
		if err != nil {
			serverErr = fmt.Errorf("server simulator: Error receiving ping req: %w", err)
			return
		}
		reqID, idOk = msg["id"]
		method, _ = msg["method"].(string)
		if !idOk || method != gomcp.MethodPing {
			serverErr = fmt.Errorf("server simulator: Expected PingRequest")
			return
		}
		log.Printf("Server simulator: Received PingRequest (ID: %v)", reqID)

		// Send Ping response (null result)
		if err := serverConn.SendResponse(reqID, nil); err != nil {
			serverErr = fmt.Errorf("server simulator: failed to send ping resp: %w", err)
			return
		}
		log.Printf("Server simulator: Sent PingResponse (ID: %v)", reqID)

		// Server simulator done
		log.Println("Server simulator finished.")

	}()

	// --- Run Client Logic Goroutine ---
	clientWg.Add(1)
	go func() {
		defer clientWg.Done()
		// Create client with its end of the pipe
		client := gomcp.NewClientWithConnection(testClientName, clientConn)
		if client == nil {
			clientErr = fmt.Errorf("NewClientWithConnection returned nil")
			return
		}
		// Run the actual client logic from main.go (now expects *Client)
		clientErr = runClientLogic(client) // Pass the client instance
	}()

	// Wait for client and server simulator to finish
	clientWg.Wait()
	serverWg.Wait()

	// Assert results
	if clientErr != nil {
		t.Errorf("Client logic failed unexpectedly: %v", clientErr)
	}
	// Server should exit cleanly with nil error or EOF/pipe error after client disconnects
	if serverErr != nil && !errors.Is(serverErr, io.EOF) && !strings.Contains(serverErr.Error(), "pipe") && !strings.Contains(serverErr.Error(), "closed") {
		// Report unexpected errors from the server goroutine
		t.Errorf("Server logic failed unexpectedly: %v", serverErr)
	} else if serverErr != nil {
		// Log expected closure errors
		t.Logf("Server exited with expected EOF/pipe error: %v", serverErr)
	} else {
		// A nil error here means the server exited cleanly, likely due to client disconnect (EOF)
		t.Log("Server exited cleanly (nil error).")
	}
}

// NOTE: Removed local BoolPtr and StringPtr helpers as they are available from main.go
